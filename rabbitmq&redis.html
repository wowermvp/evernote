<html>
<head>
  <title>rabbitmq&amp;redis</title>
  <basefont face="宋体" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/600718 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 宋体;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="551"/>
<h1>rabbitmq&amp;redis</h1>

<div>
<span><div>    RabbitMQ是一个消息代理，从“生产者”接收消息并传递消息至“消费者”，期间可根据规则路由、缓存、持久化消息。“生产者”也即message发送者以下简称P，相对应的“消费者”乃message接收者以下简称C，message通过queue由P到C，queue存在于RabbitMQ，可存储尽可能多的message，多个P可向同一queue发送message，多个C可从同一个queue接收message。</div><div><br/></div><div>日志目录：默认/var/log/rabbitmq</div><div>默认virtual host与默认user</div><div>    virtual host:/</div><div>    user:guest</div><div>    passwd:guest</div><div>    注：默认用户只可在localhost上连至/且有全部权限</div><div><br/></div><div><b>应用场景1</b></div><div>    一个P向queue发送一个message，一个C从该queue接收message并打印。</div><div><img src="rabbitmq&redis_files/Image.png" type="image/png" data-filename="Image.png" style="font-size: 9pt;"/></div><div><br/></div><div>producer.py</div><div>producer，连接至RabbitMQ Server，声明队列，发送message，关闭连接，退出。</div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">#!/usr/bin/env python3</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">#encoding:utf8</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">import pika</span></div><div><br style="font-size: 9pt;"/></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(50, 135, 18); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">#与RabbitMQ Server建立连接</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(50, 135, 18); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">#连接到的broker在本机localhost上</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">connection = pika.BlockingConnection(pika.ConnectionParameters(host='localhost'))</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">channel = connection.channel()</span></div><div><br style="font-size: 9pt;"/></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(50, 135, 18); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">#声明队列以向其发送消息</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(50, 135, 18); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">#向不存在的位置发送消息时RabbitMQ将消息丢弃</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(50, 135, 18); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">#queue='hello'指定队列名字</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">channel.queue_declare(queue='hello', durable=True)</span></div><div><br style="font-size: 9pt;"/></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(50, 135, 18); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">#message不能直接发送给queue，需经exchange到达queue，此处使用空字符串标识的默认的exchange</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(50, 135, 18); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">#使用默认exchange时允许通过routing_key明确指定message将被发送给哪个queue</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(50, 135, 18); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">#body参数指定了要发送的message内容</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">channel.basic_publish(exchange='', routing_key='hello', body='hello world!')</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">print(&quot;[x] sent 'hello world!'&quot;)</span></div><div><br style="font-size: 9pt;"/></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(50, 135, 18); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">#关闭与RabbitMQ Server间的连接</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">connection.close()</span></div></div><div><br/></div><div>consumer.py</div><div>consumer，连接至RabbitMQ Server，声明队列，接收消息并进行处理这里为打印出消息，退出。</div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">#!/usr/bin/env python3</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">#encoding:utf-8</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">import pika</span></div><div><br style="font-size: 9pt;"/></div><div><span style="font-size: 9pt;"><span style="background-color: rgb(251, 250, 248); font-size: 9pt; color: rgb(50, 135, 18); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">#建立到达RabbitMQ Server的connection</span></span></div><div><span style="font-size: 9pt;"><span style="background-color: rgb(251, 250, 248); font-size: 9pt; color: rgb(50, 135, 18); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">#此处RabbitMQ Server位于本机localhost</span></span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">connection = pika.BlockingConnection(pika.ConnectionParameters(host='localhost'))</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">channel = connection.channel()</span></div><div><br style="font-size: 9pt;"/></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(50, 135, 18); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">#声明queue，确认要从接收message的queue</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(50, 135, 18); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">#queue_declare函数是幂等的，可运行多次，但只会创建一次</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(50, 135, 18); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">#若可以确信queue是已存在的，则此处可省略该声明，如producer已经生成了该queue</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(50, 135, 18); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">#但在producer和consumer中重复声明queue是一个好习惯</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">channel.queue_declare(queue='hello')</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">print(&quot;[*] Waiting for message. To exit press CTRL + C&quot;)</span></div><div><br style="font-size: 9pt;"/></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(50, 135, 18); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">#定义回调函数</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(50, 135, 18); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">#一旦从queue中接收到一个message回调函数将被调用</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(50, 135, 18); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">#ch:channel</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(50, 135, 18); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">#method:</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(50, 135, 18); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">#properties:</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(50, 135, 18); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">#body:message</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">def callback(ch, method, properties, body):</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    print(&quot;[x] Received %r&quot; % (body,))</span></div><div><br style="font-size: 9pt;"/></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(50, 135, 18); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">#从queue接收message的参数设置</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(50, 135, 18); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">#包括从哪个queue接收message，用于处理message的callback，是否要确认message</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(50, 135, 18); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">#默认情况下是要对消息进行确认的，以防止消息丢失</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(50, 135, 18); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">#此处将no_ack明确指明True，不对消息进行确认。</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">channel.basic_consume(callback, quue='hello', no_ack=True)</span></div><div><span style="font-size: 9pt;"><span style="background-color: rgb(251, 250, 248); font-size: 9pt; color: rgb(50, 135, 18); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">#开始循环从queue中接收message并使用callback进行处理</span></span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">channel.start_consuming()</span></div></div><div><br/></div><div><br/></div><div><b>应用场景2-work&amp;queues</b></div><div>    将耗时的消息处理通过队列分配给多个consumer来处理，我们称此处的consumer为worker，我们将此处的queue称为task queue，其目的是为了避免资源密集型的task的同步处理，也即立即处理task并等待完成。相反，调度task使其稍后被处理。也即把task封闭进message并发送到task queue，worker进程在后台运行，从task queue取出task并执行job，若运行了多个worker，则task可在多个worker间分配。</div><div><img src="rabbitmq&redis_files/Image [1].png" type="image/png" data-filename="Image.png" style="font-size: 9pt;"/></div><div><br/></div><div>task.py</div><div>建立连接，声明队列，发送可以模拟耗时任务的message，断开连接，退出。</div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">#!/usr/bin/env python3</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">#encoding:utf-8</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">import pika</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">import time</span></div><div><br style="font-size: 9pt;"/></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">connection = pika.BlockingConnection(pika.ConnectionParameters(host='localhost'))</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">channel = connection.channel()</span></div><div><br style="font-size: 9pt;"/></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(50, 135, 18); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">#仅仅对message进行确认不能保证message不丢失，比如RabbitMQ崩溃了queue丢失</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(50, 135, 18); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">#因此还需使用</span><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(227, 0, 0); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">durable=True</span><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(50, 135, 18); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">声明queue是持久化的，这样即便RabbitMQ崩溃了重启后queue仍然存在</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">chanel.queue_declare(queue='task_queue', durable=True)</span></div><div><br style="font-size: 9pt;"/></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(50, 135, 18); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">#从命令行构造将要发送的message</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">message = ' '.join(sys.argv[1:]) or &quot;hello world!&quot;</span></div><div><br style="font-size: 9pt;"/></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(50, 135, 18); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">#除了声明queue是持久化的外，还需要声明message是持久化的</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(50, 135, 18); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">#basic_publish的properties参数指定message属性</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(50, 135, 18); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">#此处pika.BasicProperties中的</span><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(227, 0, 0); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">delivery_mode=2</span><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(50, 135, 18); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">指明message为持久的</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(50, 135, 18); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">#这样一来RabbitMQ崩溃重启后queue仍然存在，其中的message也仍然存在</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(50, 135, 18); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">#需要注意的是将message标记为持久的并不能完全保证message不丢失，因为</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(50, 135, 18); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">#从RabbitMQ接收到message到其存储至disk仍需一段时间，若此时RabbitMQ崩溃则message会丢失</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(50, 135, 18); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">#况且RabbitMQ不会对每条message做fsync动作</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(50, 135, 18); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">#可通过publisher confirms实现更强壮的持久保证</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; line-height: 1.45;">chanel.basic_publish(exchange='',</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">                     routing_key='task_queue',</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">                     body=message,</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">                     properties=pika.BasicProperties(delivery_mode=2,))</span></div><div><br style="font-size: 9pt;"/></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">print(&quot;[x] sent %r&quot; % message)</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">connection.close()</span></div></div><div><br/></div><div>worker.py</div><div>建立连接，声明队列，不断的接收message,处理任务，进行确认。</div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">#!/usr/bin/env python3</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">#encoding:utf-8</span></div><div><br style="font-size: 9pt;"/></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px;"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(50, 135, 18); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">#默认情况RabbitMQ将message以round-robin方式发送给下一个consumer</span></span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px;"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(50, 135, 18); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">#每个consumer接收到的平均message量是一样的</span></span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px;"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(50, 135, 18); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">#可以同时运行两个或三个该程序进行测试</span></span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">connection = pika.BlockingConnection(pika.ConnectionPraameters(host='localhost'))</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">channel = connection.channel()</span></div><div><br style="font-size: 9pt;"/></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px;"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(50, 135, 18); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">#仅仅对message进行确认不能保证message不丢失，比如RabbitMQ崩溃了</span></span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(50, 135, 18); font-family: Monaco;">#因此还需使用</span><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(227, 0, 0); font-family: Monaco;">durable=True</span><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(50, 135, 18); font-family: Monaco;">声明queue是持久化的，这样即便RabbitMQ崩溃了重启后queue仍然存在，其中的message不会丢失</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(50, 135, 18); font-family: Monaco;">#RabbitMQ中不允许使用不同的参数定义同名的queue</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">channel.queue_declare(queue='task_queue', durable=Ture)</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">print(&quot;[*] Waiting for message. To exit press CTRL + C&quot;)</span></div><div><br style="font-size: 9pt;"/></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(50, 135, 18); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">#回调函数，函数体模拟耗时的任务处理：以message中'.'的数量表示sleep的秒数</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">def callback(ch, method, properties, body):</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    print(&quot;[x] received %r&quot; % body)</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    time.sleep(body.count('.'))</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    </span><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; line-height: 1.45;">print(&quot;[x] done&quot;)</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">   </span> <span style="font-size: 9pt; background-color: rgb(251, 250, 248);"><span style="background-color: rgb(251, 250, 248); font-size: 9pt; color: rgb(50, 135, 18); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">#对message进行确认</span></span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    ch.basic_ack(delivery_tag=method.delivery_tag)</span></div><div><br style="font-size: 9pt;"/></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(50, 135, 18); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">#若存在多个consumer每个consumer的负载可能不同，有些处理的快有些处理的慢</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(50, 135, 18); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">#RabbitMQ并不管这些，只是简单的以round-robin的方式分配message</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(50, 135, 18); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">#这可能造成某些consumer积压很多任务处理不完而一些consumer长期牌饥饿状态</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(50, 135, 18); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">#可以使用</span><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(227, 0, 0); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">prefetch_count=1</span><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(50, 135, 18); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">的basic_qos方法可告知RabbitMQ只有在consumer处理并确认了一个message后才分配新的message给他</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(50, 135, 18); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">#否则分给另一个空闲的consume</span><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">r</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">channel.basic_qos(prefetch_count=1)</span></div><div><br style="font-size: 9pt;"/></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(50, 135, 18); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">#这里除了</span><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(227, 0, 0); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">no_ack=True</span><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(50, 135, 18); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">这个参数，也即需要对message进行确认（默认行为）</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(50, 135, 18); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">#否则consumer在偶然down后，其正在处理和分配到该consumer还未处理message可能发生丢失</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(50, 135, 18); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">#因为此时RabbitMQ在发送完message后立即从内存删除该message</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(50, 135, 18); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">#假如没有设置</span><span style="background-color: rgb(251, 250, 248); font-size: 12px;"><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(227, 0, 0); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">no_ack=True</span></span><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(50, 135, 18); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">则consumer在偶然down掉后其正在处理和分配至该consumer但还未来得及处理的message会重新分配到其他consumer</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(50, 135, 18); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">#没有设置no_ack=True则consumer在收到message后会向RabbitMQ反馈已收到并处理了message告诉RabbitMQ可以删除该message</span></div><div><span style="background-color: rgb(251, 250, 248); font-size: 12px; color: rgb(50, 135, 18); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">#RabbitMQ中没有超时的概念，只有在consumer down掉后重新分发message</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">channel.basic_consume(callback, queue='task_queue')</span></div><div><span style="font-size: 9pt; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">channel.start_consuming()</span></div></div><div><br/></div><div><br/></div><div><b>应用场景3-publish&amp;subscribe</b></div><div>    在应用场景2中一个message(task)仅被传递给了一个consumer(worker)。现在我们设法将一个message传递给多个consumer。这种模式被称为publish/subscribe。此处以一个简单的日志系统为例进行说明。该系统包含一个log发送程序和一个log接收并打印的程序。由log发送者发送到queue的消息可以被所有运行的log接收者接收。因此，我们可以运行一个log接收者直接在屏幕上显示log，同时运行另一个log接收者将log写入磁盘文件。</div><div><img src="rabbitmq&redis_files/Image [2].png" type="image/png" data-filename="Image.png" style="font-size: 9pt;"/></div><div>fanout_producer.py</div><div>日志消息发送者：建立连接，声明fanout类型的exchange，通过exchange向queue发送日志消息，消息被广播给所有接收者，关闭连接，退出。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;-en-codeblock:true;"><div><span style="font-size: 9pt;">#!/usr/bin/env python3</span></div><div><span style="font-size: 9pt;">#encoding:utf8</span></div><div><span style="font-size: 9pt;">import pika</span></div><div><span style="font-size: 9pt;">import sys</span></div><div><br style="font-size: 9pt;"/></div><div><font color="#328712">#producer只能通过exchange将message发给queue</font></div><div><font color="#328712">#exchange的类型决定将message路由臵哪些queue</font></div><div><font color="#328712">#可用exchange类型：direct\topic\headers\fanout</font></div><div><font color="#328712">#此处定义一个名称为'logs'的'fanout'类型的exchange，'fanout'类型的exchange简单的将message广播到它所知道的所有queue</font></div><div><span style="font-size: 9pt;">connection = pika.BlockingConnection(pika.ConnectionParameter(host='localhost'))</span></div><div><span style="font-size: 9pt;">channel = connection.channel()</span></div><div><br style="font-size: 9pt;"/></div><div><span style="font-size: 9pt;">channel.exchange_declare(exchange='logs', <font style="color: rgb(227, 0, 0);">exchange_type</font>=fanout)    <font style="color: rgb(50, 135, 18);">#pika有的版本可以直接用type字段，有的版本只能用exchange_type</font></span></div><div><span style="font-size: 9pt;">message = ' '.join(sys.argv[1:]) or &quot;info:hello world!&quot;</span></div><div><br style="font-size: 9pt;"/></div><div><font color="#328712">#将message publish到名为log的exchange中</font></div><div><font color="#328712">#因为fanout类型的exchange，这里无需指定ronting_key</font></div><div><span style="font-size: 9pt;">channel.basic_publish(exchange='logs', routing_key='', body=message)</span></div><div><span style="font-size: 9pt;">connection.close()</span></div></div><div><br/></div><div><br/></div><div>fanout_consumer.py</div><div>日志消息接收者：建立连接，声明exchange，将exchange与queue进行绑定，开始不停的接收log并打印。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;-en-codeblock:true;"><div><span style="font-size: 9pt;">#!/usr/bin/env python3</span></div><div><span style="font-size: 9pt;">#encoding:utf8</span></div><div><span style="font-size: 9pt;">import pika</span></div><div><br style="font-size: 9pt;"/></div><div><span style="font-size: 9pt;">connection = pika.BlockingConnection(pika.ConnectionParameter(host='localhost'))</span></div><div><span style="font-size: 9pt;">channel = connection.channel()</span></div><div><br style="font-size: 9pt;"/></div><div><font style="color: rgb(50, 135, 18);">#作为好的习惯，在producer和consumer中分别声明一次以保证所要使用的exchange存在</font></div><div><span style="font-size: 9pt;">channel.exchange_declare(exchange='logs', exchange_type='fanout')</span></div><div><br style="font-size: 9pt;"/></div><div><font color="#328712">#在不同的producer和consumer间共享queue时指明queue的name是重要的</font></div><div><font color="#328712">#但某些时候，比如日志系统，需要接收所有的log message而非一个子集</font></div><div><font color="#328712">#而且仅对当前的message流感兴趣，对于过时的message不感兴趣，那么</font></div><div><font color="#328712">#可以申请一个临时队列这样，每次连接到RabbitMQ时会以一个随机的名字生成</font></div><div><font color="#328712">#一个新的空的queue，将exclusive置为True，这样在consumer从RabbitMQ断开后会删除该queue</font></div><div><span style="font-size: 9pt;">result = channel.queue_declare(exclusive=True)</span></div><div><br style="font-size: 9pt;"/></div><div><font style="color: rgb(50, 135, 18);">#用于获取临时queue的name</font></div><div><span style="font-size: 9pt;">queue_name = result.method.queue</span></div><div><br style="font-size: 9pt;"/></div><div><font color="#328712">#exchange与queue之间的关系成国binding</font></div><div><font color="#328712">#binding告诉exchange将message发送该哪些queue</font></div><div><span style="font-size: 9pt;">channel.queue_bind(exchange='logs', queue=queue_name)</span></div><div><span style="font-size: 9pt;">print(&quot;[*] Waiting for logs. To exit press CTRL + C&quot;)</span></div><div><span style="font-size: 9pt;">def callback(ch, method, properties, body):</span></div><div><span style="font-size: 9pt;">    print(&quot;[x] %r&quot; % body)</span></div><div><br style="font-size: 9pt;"/></div><div><font style="color: rgb(50, 135, 18);">#从指定地queue中consume message且不确认</font></div><div><span style="font-size: 9pt;">channel.basic_consume(callback, queue=queue_name, no_ack=True)</span></div><div><span style="font-size: 9pt;">channel.start_consuming()</span></div></div><div><br/></div><div><br/></div><div><b>应用场景4-Routing</b></div><div><span>    </span>应用场景3中构建了简单的log系统，可以将log message广播多个receiver。现在我们将考虑只把指定的message类型发送给其subcriber，比如，只把error message写到log file而将所有log message显示在控制台。</div><div><img src="rabbitmq&redis_files/Image [3].png" type="image/png" data-filename="Image.png" style="font-size: 9pt;"/></div><div>derect_producer.py</div><div>log message发送者：建立连接，声明direct类型exchange，生成并发送log message到exchange，关闭连接，退出。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;-en-codeblock:true;"><div><span style="font-size: 9pt;">#!/usr/bin/env python3</span></div><div><span style="font-size: 9pt;">#encoding:utf-8</span></div><div><span style="font-size: 9pt;">import pika</span></div><div><span style="font-size: 9pt;">import sys</span></div><div><span style="font-size: 9pt;">connection = pika.BlockingConnection(pika.ConnectionParameters(host='localhost'))</span></div><div><span style="font-size: 9pt;">channel = connection.channel()</span></div><div><br style="font-size: 9pt;"/></div><div><font color="#328712">#声明一个名为direct_logs的direct类型的exchange</font></div><div><font color="#328712">#direct类型的exchange</font></div><div><span style="font-size: 9pt;">channel.exchange_declare(exchange='direct_logs', exchange_type='direct')</span></div><div><span style="font-size: 9pt;"><br/></span></div><div><span style="font-size: 9pt;"><font style="color: rgb(50, 135, 18);">#从命令行获取basic_publish的配置参数</font></span></div><div><span style="font-size: 9pt;">severity = sys.argv[1] if len(sys.argv) &gt; 1 else 'info'</span></div><div><span style="font-size: 9pt;">message = ' '.join(sys.argv[2:]) or 'hello world!'</span></div><div><span style="font-size: 9pt;"><br/></span></div><div><span style="font-size: 9pt;"><font style="color: rgb(50, 135, 18);">#向名为direct_logs的exchange按照设置的routing_key发送message</font></span></div><div>channel.basic_publish(exchange='direct_logs', routing_key=severity, body=message)</div><div>print(&quot;[x] sent %r:%r&quot; % (severity, message))</div><div>connection.close()</div></div><div><br/></div><div>direct_consumer.py</div><div>log message接收者：建立连接，声明direct类型的exchange，声明queue，使用提供的参数作为routing_key将queue绑定到exchange，开始循环接收log message并打印。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;-en-codeblock:true;"><div><span style="font-size: 9pt;">#!/usr/bin/env python3</span></div><div><span style="font-size: 9pt;">#encoding:utf-8</span></div><div><span style="font-size: 9pt;">import pika</span></div><div><span style="font-size: 9pt;">import sys</span></div><div><br style="font-size: 9pt;"/></div><div><span style="font-size: 9pt;">connection = pika.BlockingConnection(pika.ConnectionParameters(host='localhost'))</span></div><div><span style="font-size: 9pt;">channel = connection.channel()</span></div><div><br style="font-size: 9pt;"/></div><div><font color="#328712">#声明一个名为direct_logs类型为direct的exchange</font></div><div><font color="#328712">#同时在producer和consumer中声明exchange或queue是个好习惯，以保证其存在</font></div><div>channel.exchange_declare(exchange='direct_logs', exchange_type='direct')</div><div>result = channel.queue_declare(exclusive=True)</div><div>queue_name = result.method.queue</div><div><br/></div><div><font style="color: rgb(50, 135, 18);">#从命令行获取参数：routing_key</font></div><div>severities = sys.argv[1:]</div><div>if not severities:</div><div>    print(&gt;&gt; sys.stderr, &quot;Usage: %s [info] [warning] [error]&quot; % sys.argv[0])</div><div>    sys.exit(1)</div><div><br/></div><div>for severity in severities:</div><div>    <font color="#328712">#exchange和queue之间的binding可接受routing_key参数</font></div><div><font color="#328712">    #该参数的意义依赖于exchange的类型</font></div><div><font color="#328712">    #fanout类型的exchange直接忽略该参数</font></div><div><font color="#328712">    #direct类型的exchange精确匹配该关键字进行message路由</font></div><div><font color="#328712">    #对多个queue使用相同的binding_key是合法的</font></div><div>    channel.queue_bind(exchange='direct_logs', queue=queue_name, routing_key=severity)</div><div><br/></div><div>print(&quot;[*] Waiting for logs. To exit press CTRL + C&quot;)</div><div><br/></div><div>def callback(ch, method, properties, body):</div><div>    print(&quot;[x] %r:%r&quot; % (method.routing_key, body,))</div><div>channel.basic_consume(callback, queue=queue_name, no_ack=True)</div><div>channel.start_consuming()</div></div><div><br/></div><div><br/></div><div><b>应用场景5-topic</b></div><div><span>    </span>应用场景4中改进的log系统中用direct类型的exchange替换应用场景3中的fanout类型exchange实现不同的log message发送给不同的subscriber（也即分别通过不同的routing_key将queue绑定到exchange，这样exchange便可将不同的message根据message内容路由至不同的queue）。但仍然存在限制，不能根据多个规则路由消息，比如接收者要么只能收error类型的log message，要么只能接收info类型的message。如果我们不仅想根据log的重要级别如info、warning、error等来进行log message路由还想同时根据log message的来源如auth、cron、kern来进行路由。为到达此目的，需要topic类型的exchange。topic类型的exchange中routing_key中可以包含两个特殊字符：“*”用于替代一个词，“#”用于0个或多个词。</div><div><img src="rabbitmq&redis_files/Image [4].png" type="image/png" data-filename="Image.png" style="font-size: 9pt;"/></div><div>topic_producer.py</div><div>log message发送者：建立连接、声明topic类型的exchange、根据程序参数构建routing_key和要发送的message，以构建的routing_key将message发送给topic类型的exchange，关闭连接，退出。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;-en-codeblock:true;"><div><span style="font-size: 9pt;">#!/usr/bin/env python3</span></div><div><span style="font-size: 9pt;">#encoding:utf-8</span></div><div><span style="font-size: 9pt;">import pika</span></div><div><span style="font-size: 9pt;">import sys</span></div><div><br style="font-size: 9pt;"/></div><div><span style="font-size: 9pt;">connection = pika.BlockingConnection(pika.ConnectionParameters(host='localhost'))</span></div><div><span style="font-size: 9pt;">channel = connection.channel()</span></div><div><br style="font-size: 9pt;"/></div><div><font color="#328712">#声明一个名为topic_logs的topic类型的exchange</font></div><div><font color="#328712">#topic类型的exchange可通过通配符对message进行匹配从而路由至不同的queue</font></div><div><span style="font-size: 9pt;">channel.exchange_declare(exchange='topic_logs', exchange_type='topic')</span></div><div><span style="font-size: 9pt;">routing_key = sys.argv[1] if len(sys.argv) &gt; 1 else 'anonymous.info'</span></div><div><span style="font-size: 9pt;">message = ' '.join(sys.argv[2:]) or 'hello world!'</span></div><div><br style="font-size: 9pt;"/></div><div><span style="font-size: 9pt;">channel.basic_publish(exchange='topic_logs', routing_key=routing_key, body=message)</span></div><div><span style="font-size: 9pt;">print(&quot;[x] sent %r:%r&quot; % (routing_key, message))</span></div><div><span style="font-size: 9pt;">connection.close()</span></div></div><div><br/></div><div>topic_consumer.py</div><div>log message接收者：建立连接，声明topic类型的exchange，声明queue，根据程序参数构造routing_key，根据routing_key将queue绑定到exchange，循环接收并处理message。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;-en-codeblock:true;"><div><span style="font-size: 9pt;">#!/usr/bin/env python3</span></div><div><span style="font-size: 9pt;">import pika</span></div><div><span style="font-size: 9pt;">import sys</span></div><div><br style="font-size: 9pt;"/></div><div><span style="font-size: 9pt;">connection = pika.BlockingConnection(pika.ConnectionParameters(host='localhost'))</span></div><div><span style="font-size: 9pt;">channel = connection.channel()</span></div><div><br style="font-size: 9pt;"/></div><div><font color="#328712">#声明一个名为topic_logs类型为topic的exchange</font></div><div><font color="#328712">#同时在producer和consumer中声明exchange和queue是个好习惯，以保证其存在</font></div><div><span style="font-size: 9pt;">channel.exchange_declare(exchange='topic_logs', exchange_type='topic')</span></div><div><span style="font-size: 9pt;">result = channel.queue_declare(exclusive=True)</span></div><div><span style="font-size: 9pt;">queue_name = result.method.queue</span></div><div><br style="font-size: 9pt;"/></div><div><font style="color: rgb(50, 135, 18);">#从命令获取参数：routing_key</font></div><div><span style="font-size: 9pt;">severities = sys.argv[1:]</span></div><div><span style="font-size: 9pt;">if not severities:</span></div><div><span style="font-size: 9pt;">    print(&gt;&gt; sys.stderr, &quot;Usage: %s [info] [warning] [error]&quot; % sys.argv[0])</span></div><div><span style="font-size: 9pt;">    sys.exit(1)</span></div><div><br style="font-size: 9pt;"/></div><div><span style="font-size: 9pt;">for severity in severities:</span></div><div><span style="font-size: 9pt;">    <font color="#328712">#exchange和queue之间的binding可接受routing_key参数</font></span></div><div><span style="font-size: 9pt;"><font color="#328712">    #该参数的意义依赖于exchange的类型</font></span></div><div><span style="font-size: 9pt;"><font color="#328712">    #fanout类型exchange直接忽略该参数</font></span></div><div><span style="font-size: 9pt;"><font color="#328712">    #topic类型的exchange精确匹配该关键字进行message路由</font></span></div><div><span style="font-size: 9pt;"><font color="#328712">    #对多个queue使用相同的binding_kye是合法的</font></span></div><div><span style="font-size: 9pt;">    channel.queue_bind(exchange='topic_logs', queue=queue_name, routing_key=severity)</span></div><div><span style="font-size: 9pt;">print(&quot;[*] Waiting for log. To exit press CTRL + C&quot;)</span></div><div><br style="font-size: 9pt;"/></div><div><span style="font-size: 9pt;">def callback(ch, method, properties, body):</span></div><div><span style="font-size: 9pt;">    print(&quot;[x] %r:%r&quot; % (method.routing_key, body,))</span></div><div><span style="font-size: 9pt;">channel.basic_consume(callback, queue=queue_name, no_ack=True)</span></div><div><span style="font-size: 9pt;">channel.start_consuming()</span></div></div><div><br/></div><div><br/></div><div><b>应用场景6-PRC</b></div><div><span>    </span>在应用场景2中描述了如何使用work queue将耗时的task分配至不同的worker中。但是，如果我们task是想在远程的计算机上运行一个函数并等待结果呢。这跟场景2中的描述是一个完全不同的故事。这一模式被称为远程过程调用。现在，我们将构建一个PRC系统，包含一个client和可扩展的PRC Server，通过返回斐波那契数来模拟PRC Service。</div><div><img src="rabbitmq&redis_files/Image [5].png" type="image/png" data-filename="Image.png" style="font-size: 9pt;"/></div><div>rpc_server.py</div><div><span>    </span>PRC server：建立连接，声明queue，定义了一个返回指定数字的斐波那契的函数，定义了一个回调函数在接收到包含参数的调用请求后调用自己的返回斐波那契数的函数并将结果发送到与接收到message的queue相关联的queue，并进行确认。开始接收调用请求并用回调函数进行请求处理。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;-en-codeblock:true;"><div><span style="font-size: 9pt;">#!/usr/bin/env python3</span></div><div><span style="font-size: 9pt;">#encoding:utf-8</span></div><div><span style="font-size: 9pt;">import pika</span></div><div><span style="font-size: 9pt;"><br/></span></div><div><font style="color: rgb(50, 135, 18);">#建立到达RabbitMQ Server的connection</font></div><div><span style="font-size: 9pt;">connection = pika.BlockingConnection(pika.ConnectionParameters(host='localhost'))</span></div><div><span style="font-size: 9pt;">channel = connection.channel()</span></div><div><span style="font-size: 9pt;"><br/></span></div><div><font style="color: rgb(50, 135, 18);">#声明一个名为rpc_queue的queue</font></div><div><span style="font-size: 9pt;">channel.queue_declare(queue='rpc_queue')</span></div><div><span style="font-size: 9pt;"><br/></span></div><div><font style="color: rgb(50, 135, 18);">#计算指定数字的斐波那契数</font></div><div><span style="font-size: 9pt;">def fib(n):</span></div><div><span style="font-size: 9pt;">    if n == 0:</span></div><div><span style="font-size: 9pt;">        return 0</span></div><div><span style="font-size: 9pt;">    elif n == 1:</span></div><div><span style="font-size: 9pt;">        return 1</span></div><div><span style="font-size: 9pt;">    else:</span></div><div><span style="font-size: 9pt;">        return fib(n-1) + fib(n-2)</span></div><div><span style="font-size: 9pt;"><br/></span></div><div><font style="color: rgb(50, 135, 18);">#回调函数，从queue接收到message后调用该函数进行处理</font></div><div><span style="font-size: 9pt;">def on_request(ch, method, props, body):</span></div><div><span style="font-size: 9pt;">    <font style="color: rgb(50, 135, 18);">#由message获取要计算斐波那契数的数字</font></span></div><div><span style="font-size: 9pt;">    n = int(body)</span></div><div><span style="font-size: 9pt;">    print(&quot;[.] fib(%s)&quot; % n)</span></div><div><span style="font-size: 9pt;">    <font style="color: rgb(50, 135, 18);">#调用fib函数获得计算结果</font><br/></span></div><div><span style="font-size: 9pt;">    response = fib(n)</span></div><div><span style="font-size: 9pt;"><br/></span></div><div><span style="font-size: 9pt;">    <font color="#328712">#exchange为空字符串则将message发送到routing_key指定的queue</font><font color="#328712"><br/></font></span></div><div><span style="font-size: 9pt;"><span><font color="#328712"><span>    #这里queue为回调函数参数props中replay_to指定的queue</span><br/></font></span></span></div><div><span style="font-size: 9pt;"><span><font color="#328712">    #要发送的message为计算所得的斐波那契数</font></span></span></div><div><span style="font-size: 9pt;"><span><font color="#328712"><span>    #properties中correlation_id指定为回调函数参数props中的correlation_id</span><br/></font></span></span></div><div><span style="font-size: 9pt;"><span><span><font color="#328712">    #最后对消息进行确认</font></span><br/></span></span></div><div><span style="font-size: 9pt;">    ch.basic_publish(exchange='',</span></div><div><span style="font-size: 9pt;"><span>    <span>    <span>    <span>    <span>     </span></span></span></span></span>routing_key=props.reply_to,</span></div><div><span style="font-size: 9pt;"><span>    <span>    <span>    <span>    <span>     </span></span></span></span></span>properties=pika.BasicProperties(correlation_id=props.correlation_id),</span></div><div><span style="font-size: 9pt;"><span>    <span>    <span>    <span>    <span>     </span></span></span></span></span>body=str(response))</span></div><div><span style="font-size: 9pt;">    ch.basic_ack(delivery_tag=method.delivery_tag)</span></div><div><span style="font-size: 9pt;"><br/></span></div><div><span style="font-size: 9pt;"><font style="color: rgb(50, 135, 18);">#只有consumer已经处理并确认了上一条message时queue才分派新的message给它</font></span></div><div><span style="font-size: 9pt;">channel.basic_qos(prefetch_count=1)</span></div><div><span style="font-size: 9pt;"><br/></span></div><div><span style="font-size: 9pt;"><font style="color: rgb(50, 135, 18);">#设置consumer参数，即从哪个queue获取消息使用哪个函数进行处理，是否对消息进行确认</font></span></div><div><span style="font-size: 9pt;">channel.basic_consume(on_request, queue='rpc_queue')</span></div><div><span style="font-size: 9pt;">print(&quot;[x] Awaiting PRC requests&quot;)</span></div><div><span style="font-size: 9pt;"><br/></span></div><div><span style="font-size: 9pt;"><font style="color: rgb(50, 135, 18);">#开始接收并处理消息</font></span></div><div><span style="font-size: 9pt;">channel.start_consuming()</span></div></div><div><br/></div><div>rpc_client.py</div><div><span>    </span>RPC client：远程过程调用发起者：定义了一个类，类中初始化到RabbitMQ Server的连接、声明回调queue、开始在回调queue上等待接收响应、定义了在回调queue上接收到响应后的处理函数on_response根据响应关联的correlation_id属性作出响应、定义了调用函数并在其中向调用queue发送包含correlation_id等属性的调用请求、初始化一个client实例，以30为参数发起远程过程调用。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;-en-codeblock:true;"><div><span style="font-size: 9pt;">#!/usr/bin/env python3</span></div><div><span style="font-size: 9pt;">#encodig:utf-8</span></div><div><span style="font-size: 9pt;">import pika</span></div><div><span style="font-size: 9pt;">import uuid</span></div><div><br/></div><div><font style="color: rgb(50, 135, 18);">#在一个类中封装了connection建立、queue声明、consumer配置、回调函数等</font></div><div><span style="font-size: 9pt;">class FibonacciRpcClient(object):</span></div><div><span style="font-size: 9pt;">    def __init__(self):</span></div><div><span style="font-size: 9pt;">        <font style="color: rgb(50, 135, 18);">#建立到RabbitMQ Server的connection</font></span></div><div><span style="font-size: 9pt;">        self.connection = pika.BlockingConnection(pika.ConnectionParameters(host='localhost'))</span></div><div><span style="font-size: 9pt;">        self.channel = self.connection.channel()</span></div><div><br style="font-size: 9pt;"/></div><div>        <font style="color: rgb(50, 135, 18);">#声明一个临时的回调队列</font></div><div><span style="font-size: 9pt;">        result = self.channel.queue_declare(exclusive=True)</span></div><div><span style="font-size: 9pt;">        self.callback_queue = result.method.queue</span></div><div><span style="font-size: 9pt;"><br/></span></div><div><span style="font-size: 9pt;">        <font color="#328712">#此处client既是producer又是consumer，因此要配置consume参数</font></span></div><div><font color="#328712">        #这里的指明从client自己创建的临时队列中接收消息</font></div><div><font color="#328712">        #并使用on_response函数处理消息</font></div><div><font color="#328712">        #不对消息进行确认</font></div><div><span style="font-size: 9pt;">        self.channel.basic_consume(self.on_response, no_ack=True, queue=self.callback_queue)</span></div><div><span style="font-size: 9pt;">    </span></div><div><span style="font-size: 9pt;">    <font color="#328712">#定义回调函数</font><font color="#328712"><br/></font></span></div><div><span style="font-size: 9pt;"><span><font color="#328712">    #比较烦的corr_id属性与props中corr_id属性的值</font></span></span></div><div><span><font color="#328712">    #若相同则respone属性为接收到的message</font></span><br/></div><div><span style="font-size: 9pt;">    def on_response(self, ch, method, props, body):</span></div><div><span style="font-size: 9pt;">        if self.corr_id == props.correlation_id:</span></div><div><span style="font-size: 9pt;">            self.response = body</span></div><div><br style="font-size: 9pt;"/></div><div><span style="font-size: 9pt;">    def call(self, n):</span></div><div><span style="font-size: 9pt;"><span>        <font style="color: rgb(50, 135, 18);">#初始化response和corr_id属性</font></span></span></div><div><span style="font-size: 9pt;">        self.response = None</span></div><div><span style="font-size: 9pt;">        self.corr_id = str(uuid.uuid4())</span></div><div><span style="font-size: 9pt;"><br/></span></div><div><span style="font-size: 9pt;"><span>        <font color="#328712">#使用默认exchange向server中定义的rpc_queue发送消息</font></span><font color="#328712"><br/></font></span></div><div><span style="font-size: 9pt;"><span><font color="#328712"><span>    <span>    #在properties中指定replay_to属性和correlation_id属性用于告知远程server</span></span><br/></font></span></span></div><div><span style="font-size: 9pt;"><span><font color="#328712">        #correlation_id属性用于匹配request和response</font></span></span></div><div><span style="font-size: 9pt;">        self.channel.basic_publish(exchange='',</span></div><div><span style="font-size: 9pt;">                                   routing_key='rpc_queue',</span></div><div><span style="font-size: 9pt;">                                   properties=pika.BasicProperties(reply_to=self.callback_queue, correlation_id=self.corr_id),</span></div><div><span style="font-size: 9pt;"><span>    <span>    <span>    <span>    <span>    <span>    <span>    <span>       <font style="color: rgb(50, 135, 18);">#message为字符串</font></span></span></span></span></span></span></span></span><br/></span></div><div><span style="font-size: 9pt;">                                   body=str(n))</span></div><div><span style="font-size: 9pt;">        while self.response is None:</span></div><div><span style="font-size: 9pt;">            self.connection.process_data_events()</span></div><div><span style="font-size: 9pt;">        return int(self.response)</span></div><div><br style="font-size: 9pt;"/></div><div><font style="color: rgb(50, 135, 18);">#生成类的实例</font></div><div><span style="font-size: 9pt;">fibonacci_rpc = FibonacciRpcClient()</span></div><div><span style="font-size: 9pt;">print(&quot;[x] Resquest fib(30)&quot;)</span></div><div><span style="font-size: 9pt;"><font style="color: rgb(50, 135, 18);">#调用实例的call方法</font></span></div><div><span style="font-size: 9pt;">response = fibonacci_rpc.call(30)</span></div><div><span style="font-size: 9pt;">print(&quot;[.] Got %r&quot; % response)</span></div></div><div><br/></div></span>
</div></body></html> 