<html>
<head>
  <title>Wireshark抓包-TCP协议包 - Hello_GY 的博客 - CSDN博客</title>
  <basefont face="宋体" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/600718 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 宋体;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="647"/>
<h1>Wireshark抓包-TCP协议包 - Hello_GY 的博客 - CSDN博客</h1>

<div>
<span><div><h1>Wireshark抓包-TCP协议包</h1></div><div>2018年08月04日 19:46:47 <a href="https://me.csdn.net/qq_40803710" style="text-decoration: none;" target="_blank">Hello_GY</a> 阅读数：195</div><div style="position:absolute;top:0px;right:0px;box-sizing:inherit;outline:0px;padding:0px;margin:0px;"></div><div><h3 style="overflow-wrap: break-word; box-sizing: border-box; outline: 0px; padding: 0px; margin: 8px 0px 16px; font-size: 22px;"></h3><h3><span style="font-weight: 700;">TCP首部格式</span></h3><h3><span style="font-weight: 700;">　　</span></h3><div><span style="font-weight: 700;">　　<img src="Wireshark抓包-TCP协议包 - Hello_GY 的博客 - CSDN博客_files/70" type="image/png" data-filename="70" height="392" style="overflow-wrap:break-word;cursor:zoom-in;box-sizing:border-box;outline:0px;margin:0px;padding:0px;max-width:100%;" width="600"/></span></div><div><span style="font-weight: 400;">　　源端口号、目的端口号：用于寻找发端和收端应用进程。这两个值加上IP首部中的源端IP地址和目的端IP地址唯一确定一个TCP连接，</span>在网络编程中，一般一个IP地址和一个端口号组合称为一个套接字（socket）。</div><div><span style="font-weight: 400;">　　序号：用来标识从TCP发端向TCP收端发送的数据字节流，它表示在这个报文段中的的第一个数据字节。在tcp中tcp用序号对每个字节进行计数</span></div><div><span style="font-weight: 400;">　　确认序号：包含发送确认的一端所期望收到的下一个序号。确认序号=序号+数据字节数+ 1</span></div><div><span style="font-weight: 400;">　　首部长度：用于记录tcp数据报首部的长度，一般为20字节，实际值为首部长度除以4。</span></div><div><span style="font-weight: 400;">　　URG： 紧急指针（ urgent pointer）有效。</span></div><div><span style="font-weight: 400;">　　ACK： 确认序号有效。</span></div><div><span style="font-weight: 400;">　　PSH： 接收方应该尽快将这个报文段交给应用层。</span></div><div><span style="font-weight: 400;">　　RST： 重建连接。</span></div><div><span style="font-weight: 400;">　　SYN： 同步序号用来发起一个连接。</span></div><div><span style="font-weight: 400;">　　FIN： 发端完成发送任务。</span></div><div><span style="font-weight: 400;">　　窗口大小：用于流量控制。</span></div><div><span style="font-weight: 400;">　　检验和：检验和覆盖了整个的 TCP报文段： TCP首部和TCP数据，与udp相似需要计算伪首部。</span></div><h3><span style="font-weight: 700;">Wireshark抓包分析TCP结构</span></h3><div><span style="font-weight: 400;">　　利用wireshark抓取一个tcp数据包，查看其具体数据结构和实际的数据：</span></div><div><span style="font-weight: 400;"><img src="Wireshark抓包-TCP协议包 - Hello_GY 的博客 - CSDN博客_files/20160401212403210" type="image/png" data-filename="20160401212403210" height="468" style="overflow-wrap:break-word;cursor:zoom-in;box-sizing:border-box;outline:0px;margin:0px;padding:0px;max-width:100%;" width="738"/></span></div><h3 style="overflow-wrap: break-word; box-sizing: border-box; outline: 0px; padding: 0px; margin: 8px 0px 16px; font-size: 22px;"></h3><h3><span style="font-weight: 700;"><img src="Wireshark抓包-TCP协议包 - Hello_GY 的博客 - CSDN博客_files/20160401212543492" type="image/png" data-filename="20160401212543492" height="190" style="overflow-wrap:break-word;cursor:zoom-in;box-sizing:border-box;outline:0px;margin:0px;padding:0px;max-width:100%;" width="619"/></span></h3><h3><span style="font-weight: 700;">　　</span></h3><div><span style="font-weight: 700;">Wireshark抓包分析TCP3次握手</span></div><div><span style="font-weight: 400;">下面通过利用http应用层连接一个网络，实现tcp的3次握手和简单的数据交换过程，下面通过抓包来实际观察这个过程。</span></div><div><span style="font-weight: 400;">　　<img src="Wireshark抓包-TCP协议包 - Hello_GY 的博客 - CSDN博客_files/20160402124248521" type="image/png" data-filename="20160402124248521" height="219" style="overflow-wrap:break-word;cursor:zoom-in;box-sizing:border-box;outline:0px;margin:0px;padding:0px;max-width:100%;" width="691"/></span></div><div><span style="font-weight: 400;">　　从第一行的tcp往下看，前面3个tcp包为3次握手的过程，接着http包说明成功建立连接，主机向服务器发送一个http应用请求，服务器收到请求后，返回一个tcp确认帧，接着发送一个http应答给主机，主机收到服务器的http应答数据后，又发送一个tcp确认帧，确认收到了数据。这样图中的前7个包实现了主机和服务器建立连接，并实现一次简单的数据请求应答过程。即下图所示的交互按键回显过程：</span></div><div><span style="font-weight: 400;"><img src="Wireshark抓包-TCP协议包 - Hello_GY 的博客 - CSDN博客_files/20160402125054946" type="image/png" data-filename="20160402125054946" height="246" style="overflow-wrap:break-word;cursor:zoom-in;box-sizing:border-box;outline:0px;margin:0px;padding:0px;max-width:100%;" width="398"/></span></div><div><span style="font-weight: 400;">接下来是按照顺序的７个数据帧的数据结构。数据帧顺序分别为：</span></div><div><span style="font-weight: 400;">　　1. 主机发起一个tcp连接请求（tcp），</span></div><div><span style="font-weight: 400;">　　2. 服务器响应连接请求（tcp），</span></div><div><span style="font-weight: 400;">　　3. 主机返回ACK完成3次握手成功建立连接（tcp），</span></div><div><span style="font-weight: 400;">　　4. 主机发送一个http网页请求（http），</span></div><div><span style="font-weight: 400;">　　5. 服务器收到请求返回一个ACK帧（tcp），</span></div><div><span style="font-weight: 400;">　　6. 服务器根据请求发送数据到主机（http），</span></div><div><span style="font-weight: 400;">　　7. 主机收到服务器数据返回一个ACK帧（tcp），具体帧细节见下图：</span></div><div><span style="font-weight: 400;"><img src="Wireshark抓包-TCP协议包 - Hello_GY 的博客 - CSDN博客_files/20160402143705176" type="image/png" data-filename="20160402143705176" height="463" style="overflow-wrap:break-word;cursor:zoom-in;box-sizing:border-box;outline:0px;margin:0px;padding:0px;max-width:100%;" width="708"/></span></div><div><span style="font-weight: 400;"><img src="Wireshark抓包-TCP协议包 - Hello_GY 的博客 - CSDN博客_files/20160402143729864" type="image/png" data-filename="20160402143729864" height="515" style="overflow-wrap:break-word;cursor:zoom-in;box-sizing:border-box;outline:0px;margin:0px;padding:0px;max-width:100%;" width="708"/></span></div><div><span style="font-weight: 400;"><img src="Wireshark抓包-TCP协议包 - Hello_GY 的博客 - CSDN博客_files/20160402143745254" type="image/png" data-filename="20160402143745254" height="474" style="overflow-wrap:break-word;cursor:zoom-in;box-sizing:border-box;outline:0px;margin:0px;padding:0px;max-width:100%;" width="710"/></span></div><div><span style="font-weight: 400;"><img src="Wireshark抓包-TCP协议包 - Hello_GY 的博客 - CSDN博客_files/20160402143808067" type="image/png" data-filename="20160402143808067" height="504" style="overflow-wrap:break-word;cursor:zoom-in;box-sizing:border-box;outline:0px;margin:0px;padding:0px;max-width:100%;" width="712"/></span></div><div><span style="font-weight: 400;"><img src="Wireshark抓包-TCP协议包 - Hello_GY 的博客 - CSDN博客_files/20160402143839848" type="image/png" data-filename="20160402143839848" height="482" style="overflow-wrap:break-word;cursor:zoom-in;box-sizing:border-box;outline:0px;margin:0px;padding:0px;max-width:100%;" width="716"/></span></div><div><span style="font-weight: 400;"><img src="Wireshark抓包-TCP协议包 - Hello_GY 的博客 - CSDN博客_files/20160402143907880" type="image/png" data-filename="20160402143907880" height="524" style="overflow-wrap:break-word;cursor:zoom-in;box-sizing:border-box;outline:0px;margin:0px;padding:0px;max-width:100%;" width="721"/></span></div><div><span style="font-weight: 400;"><img src="Wireshark抓包-TCP协议包 - Hello_GY 的博客 - CSDN博客_files/20160402143929396" type="image/png" data-filename="20160402143929396" height="486" style="overflow-wrap:break-word;cursor:zoom-in;box-sizing:border-box;outline:0px;margin:0px;padding:0px;max-width:100%;" width="722"/></span></div><div><span style="font-weight: 400;">下面通过wireshark抓包了解具体的释放连接过程，通过断开一个连接，抓取到4个TCP帧，帧顺序依次为：</span></div><div><br style="overflow-wrap:break-word;box-sizing:border-box;outline:0px;margin:0px;padding:0px;"/></div><div><span style="font-weight: 400;">　　1. 主动关闭放发送一个FIN帧给被动方</span></div><div><span style="font-weight: 400;">　　2. 被动方收到关闭信息返回一个确认ACK帧</span></div><div><span style="font-weight: 400;">　　3. 被动方发送一个FIN帧给主动方</span></div><div><span style="font-weight: 400;">　　4. 主动方收到被动方的FIN关闭信息返回一个ACK帧，连接释放</span></div><div><span style="font-weight: 400;">下面为按照顺序的帧数据结构详细信息：</span></div><div><span style="font-weight: 400;"><img src="Wireshark抓包-TCP协议包 - Hello_GY 的博客 - CSDN博客_files/20160402160804805" type="image/png" data-filename="20160402160804805" height="531" style="overflow-wrap:break-word;cursor:zoom-in;box-sizing:border-box;outline:0px;margin:0px;padding:0px;max-width:100%;" width="726"/></span></div><div><span style="font-weight: 400;"><img src="Wireshark抓包-TCP协议包 - Hello_GY 的博客 - CSDN博客_files/20160402160826898" type="image/png" data-filename="20160402160826898" height="541" style="overflow-wrap:break-word;cursor:zoom-in;box-sizing:border-box;outline:0px;margin:0px;padding:0px;max-width:100%;" width="728"/></span></div><div><span style="font-weight: 400;"><img src="Wireshark抓包-TCP协议包 - Hello_GY 的博客 - CSDN博客_files/20160402160846055" type="image/png" data-filename="20160402160846055" height="571" style="overflow-wrap:break-word;cursor:zoom-in;box-sizing:border-box;outline:0px;margin:0px;padding:0px;max-width:100%;" width="727"/></span></div><div><span style="font-weight: 400;"><img src="Wireshark抓包-TCP协议包 - Hello_GY 的博客 - CSDN博客_files/20160402160856102" type="image/png" data-filename="20160402160856102" height="555" style="overflow-wrap:break-word;cursor:zoom-in;box-sizing:border-box;outline:0px;margin:0px;padding:0px;max-width:100%;" width="729"/></span></div><div><span style="font-weight: 400;">TCP的最大报文段长度</span></div><div><span style="font-weight: 400;">　　最大报文段长度（MSS）表示TCP传往另一端的最大块数据的长度。当一个连接建立时，连接的双方都要通告各自的MSS。一般来说，MSS越大越好，因为报文段越大允许每个报文段传送的数据就越多，相对IP和TCP首部有更高的网络利用率。</span></div><div><span style="font-weight: 400;">　　MSS选项只能出现在SYN报文段中，所以只能在SYN=1的帧中才会有MSS选项说明报文的最大段长度。</span></div></div><div style="height: 0px; visibility: hidden; clear: both;"></div><div><br/></div></span>
</div></body></html> 