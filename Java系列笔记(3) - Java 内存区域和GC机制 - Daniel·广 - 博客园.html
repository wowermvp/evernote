<html>
<head>
  <title>Java系列笔记(3) - Java 内存区域和GC机制 - Daniel·广 - 博客园</title>
  <basefont face="宋体" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/600718 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 宋体;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1151"/>
<h1>Java系列笔记(3) - Java 内存区域和GC机制 - Daniel·广 - 博客园</h1>

<div><span>
  <div>
<div style="font-size: 16px; display: inline-block; min-width: 100%;"><div><div style="font-family:&quot;PingFang SC&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif;color:rgb(0, 0, 0);background:rgb(210, 216, 222);font:12px/1.5 tahoma, arial, sans-serif;text-size-adjust:none;font-size:14px;"><div><div><div style="text-overflow:ellipsis;overflow:hidden;word-break:break-all;"><div><div><div style="background:rgb(255, 255, 255);border-radius:7px;box-shadow:rgb(167, 168, 173) 1px 1px 2px;text-overflow:ellipsis;overflow:hidden;word-break:break-all;"><div>
		<h1 style="margin:0px;padding:0px;font-size:1.5em;font-weight:bold;line-height:1.5em;width:100%;clear:both;text-align:center;">
			<a href="https://www.cnblogs.com/zhguang/p/3257367.html" style="margin:0px;padding:0px;color:rgb(46, 177, 232);text-decoration:none;font-size:1.5rem;font-weight:bold;text-shadow:rgb(167, 168, 173) 0px 0px 1px;line-height:1.5em;">Java系列笔记(3) - Java 内存区域和GC机制</a>
		</h1>
		<div style="clear:both;margin:0px;padding:0px;"></div>
		<div style="margin:0px;padding:5px;line-height:1.5;color:rgb(68, 68, 68);">
			<div style="margin-bottom:20px;word-break:break-word;margin:0px;padding:0px;"><p style="margin:10px auto;text-indent:0px;padding:0px;line-height:1.5;">目录</p>
<ol style="padding-left:40px;margin:0px;padding:0px;">
<li style="list-style-type:decimal;margin:0px;padding:0px;list-style:none;margin-bottom:1em;"><a href="https://www.cnblogs.com/zhguang/p/3257367.html#introduction" style="margin:0px;padding:0px;color:rgb(68, 68, 68);text-decoration:underline;">Java垃圾回收概况</a></li>
<li style="list-style-type:decimal;margin:0px;padding:0px;list-style:none;margin-bottom:1em;"><a href="https://www.cnblogs.com/zhguang/p/3257367.html#memoryArea" style="margin:0px;padding:0px;color:rgb(68, 68, 68);text-decoration:underline;">Java内存区域</a></li>
<li style="list-style-type:decimal;margin:0px;padding:0px;list-style:none;margin-bottom:1em;"><a href="https://www.cnblogs.com/zhguang/p/3257367.html#access" style="margin:0px;padding:0px;color:rgb(68, 68, 68);text-decoration:underline;">Java对象的访问方式</a></li>
<li style="list-style-type:decimal;margin:0px;padding:0px;list-style:none;margin-bottom:1em;"><a href="https://www.cnblogs.com/zhguang/p/3257367.html#distribution" style="margin:0px;padding:0px;color:rgb(68, 68, 68);text-decoration:underline;">Java内存分配机制</a></li>
<li style="list-style-type:decimal;margin:0px;padding:0px;list-style:none;margin-bottom:1em;"><a href="https://www.cnblogs.com/zhguang/p/3257367.html#GCScheama" style="margin:0px;padding:0px;color:rgb(68, 68, 68);text-decoration:underline;">Java GC机制</a></li>
<li style="list-style-type:decimal;margin:0px;padding:0px;list-style:none;margin-bottom:1em;"><a href="https://www.cnblogs.com/zhguang/p/3257367.html#GCparam" style="margin:0px;padding:0px;color:rgb(68, 68, 68);text-decoration:underline;">垃圾收集器</a></li>
</ol>
<p style="margin:10px auto;text-indent:0px;padding:0px;line-height:1.5;"><strong style="margin:0px;padding:0px;"><a name="introduction" style="margin:0px;padding:0px;"></a>Java垃圾回收概况</strong></p>
<p style="margin:10px auto;text-indent:0px;padding:0px;line-height:1.5;">　　Java GC（Garbage Collection，垃圾收集，垃圾回收）机制，是Java与C++/C的主要区别之一，作为Java开发者，一般不需要专门编写内存回收和垃圾清理代码，对内存泄露和溢出的问题，也不需要像C程序员那样战战兢兢。这是因为在Java虚拟机中，存在自动内存管理和垃圾清扫机制。概括地说，该机制对JVM（Java Virtual Machine）中的内存进行标记，并确定哪些内存需要回收，根据一定的回收策略，自动的回收内存，永不停息（Nerver Stop）的保证JVM中的内存空间，防止出现内存泄露和溢出问题。</p>
<p style="margin:10px auto;text-indent:0px;padding:0px;line-height:1.5;"><span style="margin:0px;padding:0px;color:#ff0000;">　　关于JVM，需要说明一下的是，目前使用最多的Sun公司的JDK中，自从1999年的JDK1.2开始直至现在仍在广泛使用的JDK6，其中默认的虚拟机都是HotSpot。2009年，Oracle收购Sun，加上之前收购的EBA公司，Oracle拥有3大虚拟机中的两个：JRockit和HotSpot，Oracle也表明了想要整合两大虚拟机的意图，但是目前在新发布的JDK7中，默认的虚拟机仍然是HotSpot，因此本文中默认介绍的虚拟机都是HotSpot，相关机制也主要是指HotSpot的GC机制。</span></p>
<p style="margin:10px auto;text-indent:0px;padding:0px;line-height:1.5;">　　Java GC机制主要完成3件事：确定哪些内存需要回收，确定什么时候需要执行GC，如何执行GC。经过这么长时间的发展（事实上，在Java语言出现之前，就有GC机制的存在，如Lisp语言），Java GC机制已经日臻完善，几乎可以自动的为我们做绝大多数的事情。然而，如果我们从事较大型的应用软件开发，曾经出现过内存优化的需求，就必定要研究Java GC机制。</p>
<p style="margin:10px auto;text-indent:0px;padding:0px;line-height:1.5;">　　学习Java GC机制，可以帮助我们在日常工作中排查各种内存溢出或泄露问题，解决性能瓶颈，达到更高的并发量，写出更高效的程序。</p>
<p style="margin:10px auto;text-indent:0px;padding:0px;line-height:1.5;">　　我们将从4个方面学习Java GC机制，1，内存是如何分配的；2，如何保证内存不被错误回收（即：哪些内存需要回收）；3，在什么情况下执行GC以及执行GC的方式；4，如何监控和优化GC机制。</p>
<p style="margin:10px auto;text-indent:0px;padding:0px;line-height:1.5;"><a name="memoryArea" style="margin:0px;padding:0px;"></a><strong style="margin:0px;padding:0px;">Java内存区域</strong></p>
<p style="margin:10px auto;text-indent:0px;padding:0px;line-height:1.5;">　　了解Java GC机制，必须先清楚在JVM中内存区域的划分。在Java运行时的数据区里，由JVM管理的内存区域分为下图几个模块：</p>
<p style="margin:10px auto;text-indent:0px;padding:0px;line-height:1.5;"><img src="Java系列笔记(3) - Java 内存区域和GC机制 - Daniel·广 - 博客园_files/Image.jpg" type="image/jpeg" data-filename="Image.jpg" height="278" style="border:0px;max-width:300px;height:auto;margin:0px;padding:0px;" width="435"/></p>
<p style="margin:10px auto;text-indent:0px;padding:0px;line-height:1.5;">其中：</p>
<p style="margin:10px auto;text-indent:0px;padding:0px;line-height:1.5;"><strong style="margin:0px;padding:0px;">1，程序计数器（Program Counter Register）</strong>：程序计数器是一个比较小的内存区域，用于指示当前线程所执行的字节码执行到了第几行，可以理解为是当前线程的行号指示器。字节码解释器在工作时，会通过改变这个计数器的值来取下一条语句指令。</p>
<p style="margin:10px auto;text-indent:0px;padding:0px;line-height:1.5;">　　每个程序计数器只用来记录一个线程的行号，所以它是<strong style="margin:0px;padding:0px;">线程私有</strong>（一个线程就有一个程序计数器）的。</p>
<p style="margin:10px auto;text-indent:0px;padding:0px;line-height:1.5;">　　如果程序执行的是一个Java方法，则计数器记录的是正在执行的虚拟机字节码指令地址；如果正在执行的是一个本地（native，由C语言编写完成）方法，则计数器的值为Undefined，由于程序计数器只是记录当前指令地址，所以不存在内存溢出的情况，因此，程序计数器也是所有JVM内存区域中唯一一个没有定义OutOfMemoryError的区域。</p>
<p style="margin:10px auto;text-indent:0px;padding:0px;line-height:1.5;"><strong style="margin:0px;padding:0px;">2，虚拟机栈（JVM Stack）</strong>：一个线程的每个方法在执行的同时，都会创建一个栈帧（Statck Frame），栈帧中存储的有局部变量表、操作站、动态链接、方法出口等，当方法被调用时，栈帧在JVM栈中入栈，当方法执行完成时，栈帧出栈。</p>
<p style="margin:10px auto;text-indent:0px;padding:0px;line-height:1.5;">　　局部变量表中存储着方法的相关局部变量，包括各种基本数据类型，对象的引用，返回地址等。在局部变量表中，只有long和double类型会占用2个局部变量空间（Slot，对于32位机器，一个Slot就是32个bit），其它都是1个Slot。需要注意的是，局部变量表是在编译时就已经确定好的，方法运行所需要分配的空间在栈帧中是完全确定的，在方法的生命周期内都不会改变。</p>
<p style="margin:10px auto;text-indent:0px;padding:0px;line-height:1.5;">　　虚拟机栈中定义了两种异常，如果线程调用的栈深度大于虚拟机允许的最大深度，则抛出StatckOverFlowError（栈溢出）；不过多数Java虚拟机都允许动态扩展虚拟机栈的大小(有少部分是固定长度的)，所以线程可以一直申请栈，直到内存不足，此时，会抛出OutOfMemoryError（内存溢出）。</p>
<p style="margin:10px auto;text-indent:0px;padding:0px;line-height:1.5;">　　每个线程对应着一个虚拟机栈，因此虚拟机栈也是线程私有的。</p>
<p style="margin:10px auto;text-indent:0px;padding:0px;line-height:1.5;"><strong style="margin:0px;padding:0px;">3，本地方法栈（Native Method Statck）</strong>：本地方法栈在作用，运行机制，异常类型等方面都与虚拟机栈相同，唯一的区别是：虚拟机栈是执行Java方法的，而本地方法栈是用来执行native方法的，在很多虚拟机中（如Sun的JDK默认的HotSpot虚拟机），会将本地方法栈与虚拟机栈放在一起使用。</p>
<p style="margin:10px auto;text-indent:0px;padding:0px;line-height:1.5;">　　本地方法栈也是线程私有的。</p>
<p style="margin:10px auto;text-indent:0px;padding:0px;line-height:1.5;"><strong style="margin:0px;padding:0px;">4，堆区（Heap）</strong>：堆区是理解Java GC机制最重要的区域，没有之一。在JVM所管理的内存中，堆区是最大的一块，堆区也是Java GC机制所管理的主要内存区域，堆区<strong style="margin:0px;padding:0px;">由所有线程共享</strong>，在虚拟机启动时创建。堆区的存在是为了<strong style="margin:0px;padding:0px;">存储对象实例</strong>，原则上讲，所有的对象都在堆区上分配内存（不过现代技术里，也不是这么绝对的，也有栈上直接分配的）。</p>
<p style="margin:10px auto;text-indent:0px;padding:0px;line-height:1.5;">　　一般的，根据Java虚拟机规范规定，堆内存需要在逻辑上是连续的（在物理上不需要），在实现时，可以是固定大小的，也可以是可扩展的，目前主流的虚拟机都是可扩展的。如果在执行垃圾回收之后，仍没有足够的内存分配，也不能再扩展，将会抛出OutOfMemoryError:<span style="margin:0px;padding:0px;font-size:small;"><span style="margin:0px;padding:0px;"><span style="margin:0px;padding:0px;">Java heap space</span></span></span>异常。</p>
<p style="margin:10px auto;text-indent:0px;padding:0px;line-height:1.5;">　　关于堆区的内容还有很多，将在下节“<strong style="margin:0px;padding:0px;">Java内存分配机制</strong>”中详细介绍。</p>
<p style="margin:10px auto;text-indent:0px;padding:0px;line-height:1.5;"><strong style="margin:0px;padding:0px;">5，方法区（Method Area）</strong>：在Java虚拟机规范中，将方法区作为堆的一个逻辑部分来对待，但事实上，方法区并不是堆（Non-Heap）；另外，不少人的博客中，将Java GC的分代收集机制分为3个代：青年代，老年代，永久代，这些作者将方法区定义为“永久代”，这是因为，对于之前的HotSpot Java虚拟机的实现方式中，将分代收集的思想扩展到了方法区，并将方法区设计成了永久代。不过，除HotSpot之外的多数虚拟机，并不将方法区当做永久代，HotSpot本身，也计划取消永久代。本文中，由于笔者主要使用Oracle JDK6.0，因此仍将使用永久代一词。</p>
<p style="margin:10px auto;text-indent:0px;padding:0px;line-height:1.5;">　　方法区是各个线程共享的区域，用于存储已经被虚拟机加载的类信息（即加载类时需要加载的信息，包括版本、field、方法、接口等信息）、final常量、静态变量、编译器即时编译的代码等。</p>
<p style="margin:10px auto;text-indent:0px;padding:0px;line-height:1.5;">　　方法区在物理上也不需要是连续的，可以选择固定大小或可扩展大小，并且方法区比堆还多了一个限制：可以选择是否执行垃圾收集。一般的，方法区上执行的垃圾收集是很少的，这也是方法区被称为永久代的原因之一（HotSpot），但这也不代表着在方法区上完全没有垃圾收集，其上的垃圾收集主要是针对常量池的内存回收和对已加载类的卸载。</p>
<p style="margin:10px auto;text-indent:0px;padding:0px;line-height:1.5;">　　在方法区上进行垃圾收集，条件苛刻而且相当困难，效果也不令人满意，所以一般不做太多考虑，可以留作以后进一步深入研究时使用。</p>
<p style="margin:10px auto;text-indent:0px;padding:0px;line-height:1.5;">　　在方法区上定义了OutOfMemoryError:<span style="margin:0px;padding:0px;font-size:small;"><span style="margin:0px;padding:0px;"><span style="margin:0px;padding:0px;">PermGen space</span></span></span>异常，在内存不足时抛出。</p>
<p style="margin:10px auto;text-indent:0px;padding:0px;line-height:1.5;">　　运行时常量池（Runtime Constant Pool）是方法区的一部分，用于存储编译期就生成的字面常量、符号引用、翻译出来的直接引用<span style="margin:0px;padding:0px;color:#ff0000;">（<span style="margin:0px;padding:0px;background-color:#ffffff;">符号引用就是编码是用字符串表示某个变量、接口的位置，直接引用就是根据符号引用翻译出来的地址，将在类链接阶段完成翻译</span>）</span>；运行时常量池除了存储编译期常量外，也可以存储在运行时间产生的常量（比如String类的intern()方法，作用是String维护了一个常量池，如果调用的字符“abc”已经在常量池中，则返回池中的字符串地址，否则，新建一个常量加入池中，并返回地址）。</p>
<p style="margin:10px auto;text-indent:0px;padding:0px;line-height:1.5;"><strong style="margin:0px;padding:0px;">6，直接内存（Direct Memory）</strong>：直接内存并不是JVM管理的内存，可以这样理解，直接内存，就是JVM以外的机器内存，比如，你有4G的内存，JVM占用了1G，则其余的3G就是直接内存，JDK中有一种基于通道（Channel）和缓冲区（Buffer）的内存分配方式，将由C语言实现的native函数库分配在直接内存中，用存储在JVM堆中的DirectByteBuffer来引用。由于直接内存收到本机器内存的限制，所以也可能出现OutOfMemoryError的异常。</p>
<p style="margin:10px auto;text-indent:0px;padding:0px;line-height:1.5;"><strong style="margin:0px;padding:0px;"><a name="access" style="margin:0px;padding:0px;"></a>Java对象的访问方式</strong></p>
<p style="margin:10px auto;text-indent:0px;padding:0px;line-height:1.5;">一般来说，一个Java的引用访问涉及到3个内存区域：JVM栈，堆，方法区。</p>
<p style="margin:10px auto;text-indent:0px;padding:0px;line-height:1.5;">　　以最简单的本地变量引用：Object obj = new Object()为例：</p>
<ul style="margin-left:30px;padding-left:0px;margin:0px;padding:0px;word-break:break-all;">
<li style="list-style-type:disc;margin:0px;padding:0px;list-style:none;margin-bottom:1em;">Object obj表示一个本地引用，存储在JVM栈的本地变量表中，表示一个reference类型数据；</li>
<li style="list-style-type:disc;margin:0px;padding:0px;list-style:none;margin-bottom:1em;">new Object()作为实例对象数据存储在堆中；</li>
<li style="list-style-type:disc;margin:0px;padding:0px;list-style:none;margin-bottom:1em;">堆中还记录了Object类的类型信息（接口、方法、field、对象类型等）的地址，这些地址所执行的数据存储在方法区中；</li>
</ul>
<p style="margin:10px auto;text-indent:0px;padding:0px;line-height:1.5;">在Java虚拟机规范中，对于通过reference类型引用访问具体对象的方式并未做规定，目前主流的实现方式主要有两种：</p>
<p style="margin:10px auto;text-indent:0px;padding:0px;line-height:1.5;">1，通过句柄访问（图来自于《深入理解Java虚拟机：JVM高级特效与最佳实现》）：</p>
<p style="margin:10px auto;text-indent:0px;padding:0px;line-height:1.5;"><img src="Java系列笔记(3) - Java 内存区域和GC机制 - Daniel·广 - 博客园_files/21174354-8e55a4e6b6284153b8ac40cfeab3062d.png" type="image/png" data-filename="21174354-8e55a4e6b6284153b8ac40cfeab3062d.png" height="320" style="border:0px;max-width:300px;height:auto;margin:0px;padding:0px;" width="660"/></p>
<p style="margin:10px auto;text-indent:0px;padding:0px;line-height:1.5;">通过句柄访问的实现方式中，JVM堆中会专门有一块区域用来作为句柄池，存储相关句柄所执行的实例数据地址（包括在堆中地址和在方法区中的地址）。这种实现方法由于用句柄表示地址，因此十分稳定。</p>
<p style="margin:10px auto;text-indent:0px;padding:0px;line-height:1.5;">2，通过直接指针访问：（图来自于《深入理解Java虚拟机：JVM高级特效与最佳实现》）</p>
<p style="margin:10px auto;text-indent:0px;padding:0px;line-height:1.5;"><img src="Java系列笔记(3) - Java 内存区域和GC机制 - Daniel·广 - 博客园_files/21174413-e7b4a7cdec984c2881a56ad776d54354.png" type="image/png" data-filename="21174413-e7b4a7cdec984c2881a56ad776d54354.png" height="323" style="border:0px;max-width:300px;height:auto;margin:0px;padding:0px;" width="660"/></p>
<p style="margin:10px auto;text-indent:0px;padding:0px;line-height:1.5;">通过直接指针访问的方式中，reference中存储的就是对象在堆中的实际地址，在堆中存储的对象信息中包含了在方法区中的相应类型数据。这种方法最大的优势是速度快，在HotSpot虚拟机中用的就是这种方式。</p>
<p style="margin:10px auto;text-indent:0px;padding:0px;line-height:1.5;"><strong style="margin:0px;padding:0px;"><a name="distribution" style="margin:0px;padding:0px;"></a>Java内存分配机制</strong></p>
<p style="margin:10px auto;text-indent:0px;padding:0px;line-height:1.5;">这里所说的内存分配，主要指的是在堆上的分配，一般的，对象的内存分配都是在堆上进行，但现代技术也支持将对象拆成标量类型（标量类型即原子类型，表示单个值，可以是基本类型或String等），然后在栈上分配，在栈上分配的很少见，我们这里不考虑。</p>
<p style="margin:10px auto;text-indent:0px;padding:0px;line-height:1.5;">　　Java内存分配和回收的机制概括的说，就是：分代分配，分代回收。对象将根据存活的时间被分为：年轻代（Young Generation）、年老代（Old Generation）、永久代（Permanent Generation，也就是方法区）。如下图（来源于《成为JavaGC专家part I》，http://www.importnew.com/1993.html）：</p>
<p style="margin:10px auto;text-indent:0px;padding:0px;line-height:1.5;">　　　　<img src="Java系列笔记(3) - Java 内存区域和GC机制 - Daniel·广 - 博客园_files/22011837-d7fa2942d1c041b8be184f503e63fa46.png" type="image/png" data-filename="22011837-d7fa2942d1c041b8be184f503e63fa46.png" height="307" style="border:0px;max-width:300px;height:auto;margin:0px;padding:0px;" width="352"/></p>
<p style="margin:10px auto;text-indent:0px;padding:0px;line-height:1.5;"><strong style="margin:0px;padding:0px;">　　年轻代（Young Generation）</strong>：对象被创建时，内存的分配首先发生在年轻代（大对象可以直接被创建在年老代），大部分的对象在创建后很快就不再使用，因此很快变得不可达，于是被年轻代的GC机制清理掉（IBM的研究表明，98%的对象都是很快消亡的），这个GC机制被称为Minor GC或叫Young GC。注意，Minor GC并不代表年轻代内存不足，它事实上只表示在Eden区上的GC。</p>
<p style="margin:10px auto;text-indent:0px;padding:0px;line-height:1.5;">　　年轻代上的内存分配是这样的，年轻代可以分为3个区域：Eden区（伊甸园，亚当和夏娃偷吃禁果生娃娃的地方，用来表示内存首次分配的区域，再贴切不过）和两个存活区（Survivor 0 、Survivor 1）。内存分配过程为（来源于《成为JavaGC专家part I》，http://www.importnew.com/1993.html）：</p>
<p style="margin:10px auto;text-indent:0px;padding:0px;line-height:1.5;">　　　　<img src="Java系列笔记(3) - Java 内存区域和GC机制 - Daniel·广 - 博客园_files/22014107-8698ab6bdb0f44389c0212ad2c1bae21.png" type="image/png" data-filename="22014107-8698ab6bdb0f44389c0212ad2c1bae21.png" height="715" style="border:0px;max-width:300px;height:auto;margin:0px;padding:0px;" width="382"/></p>
<div style="margin:0px;padding:0px;line-height:1.5;"><ol style="padding-left:40px;margin:0px;padding:0px;">
<li style="list-style-type:decimal;margin:0px;padding:0px;list-style:none;margin-bottom:1em;">
<div style="margin:0px;padding:0px;line-height:1.5;">绝大多数刚创建的对象会被分配在Eden区，其中的大多数对象很快就会消亡。Eden区是连续的内存空间，因此在其上分配内存极快；</div>
</li>
<li style="list-style-type:decimal;margin:0px;padding:0px;list-style:none;margin-bottom:1em;">
<div style="margin:0px;padding:0px;line-height:1.5;">最初一次，当Eden区满的时候，执行Minor GC，将消亡的对象清理掉，并将剩余的对象复制到一个存活区Survivor0（此时，Survivor1是空白的，两个Survivor总有一个是空白的）；</div>
</li>
<li style="list-style-type:decimal;margin:0px;padding:0px;list-style:none;margin-bottom:1em;">
<div style="margin:0px;padding:0px;line-height:1.5;"> 下次Eden区满了，再执行一次Minor GC，将消亡的对象清理掉，将存活的对象复制到Survivor1中，然后清空Eden区；</div>
</li>
<li style="list-style-type:decimal;margin:0px;padding:0px;list-style:none;margin-bottom:1em;">
<div style="margin:0px;padding:0px;line-height:1.5;"> 将Survivor0中消亡的对象清理掉，将其中可以晋级的对象晋级到Old区，将存活的对象也复制到Survivor1区，然后清空Survivor0区；</div>
</li>
<li style="list-style-type:decimal;margin:0px;padding:0px;list-style:none;margin-bottom:1em;">当两个存活区切换了几次（HotSpot虚拟机默认15次，用-XX:MaxTenuringThreshold控制，大于该值进入老年代，但这只是个最大值，并不代表一定是这个值）之后，仍然存活的对象（其实只有一小部分，比如，我们自己定义的对象），将被复制到老年代。</li>
</ol></div>
<p style="margin:10px auto;text-indent:0px;padding:0px;line-height:1.5;">　　从上面的过程可以看出，Eden区是连续的空间，且Survivor总有一个为空。经过一次GC和复制，一个Survivor中保存着当前还活着的对象，而Eden区和另一个Survivor区的内容都不再需要了，可以直接清空，到下一次GC时，两个Survivor的角色再互换。因此，这种方式分配内存和清理内存的效率都极高，这种垃圾回收的方式就是著名的<span style="margin:0px;padding:0px;color:#ff0000;"><span style="margin:0px;padding:0px;color:#000000;"><strong style="margin:0px;padding:0px;">“停止-复制（Stop-and-copy）”清理法（将Eden区和一个Survivor中仍然存活的对象拷贝到另一个Survivor中）</strong>，这不代表着停止复制清理法很高效，其实，它也只在这种情况下高效，如果在老年代采用停止复制，则挺悲剧的</span></span>。</p>
<p style="margin:10px auto;text-indent:0px;padding:0px;line-height:1.5;">　　在Eden区，HotSpot虚拟机使用了两种技术来加快内存分配。分别是bump-the-pointer和TLAB（Thread-Local Allocation Buffers），这两种技术的做法分别是：由于Eden区是连续的，因此bump-the-pointer技术的核心就是跟踪最后创建的一个对象，在对象创建时，只需要检查最后一个对象后面是否有足够的内存即可，从而大大加快内存分配速度；而对于TLAB技术是对于多线程而言的，将Eden区分为若干段，每个线程使用独立的一段，避免相互影响。TLAB结合bump-the-pointer技术，将保证每个线程都使用Eden区的一段，并快速的分配内存。</p>
<p style="margin:10px auto;text-indent:0px;padding:0px;line-height:1.5;"><strong style="margin:0px;padding:0px;">　　年老代（Old Generation）</strong>：对象如果在年轻代存活了足够长的时间而没有被清理掉（即在几次Young GC后存活了下来），则会被复制到年老代，年老代的空间一般比年轻代大，能存放更多的对象，在年老代上发生的GC次数也比年轻代少。当年老代内存不足时，将执行Major GC，也叫 Full GC。　　</p>
<div style="margin:0px;padding:0px;line-height:1.5;">
<div style="margin:0px;padding:0px;line-height:1.5;"> 　　可以使用-XX:+UseAdaptiveSizePolicy开关来控制是否采用动态控制策略，如果动态控制，则动态调整Java堆中各个区域的大小以及进入老年代的年龄。</div>
<p style="margin:10px auto;text-indent:0px;padding:0px;line-height:1.5;">　　如果对象比较大（比如长字符串或大数组），Young空间不足，则大对象会直接分配到老年代上（大对象可能触发提前GC，应少用，更应避免使用短命的大对象）。<span style="margin:0px;padding:0px;color:#2d4fc9;">用-XX:PretenureSizeThreshold来控制直接升入老年代的对象大小，大于这个值的对象会直接分配在老年代上。</span></p>
</div>
<p style="margin:10px auto;text-indent:0px;padding:0px;line-height:1.5;">　　可能存在年老代对象引用新生代对象的情况，如果需要执行Young GC，则可能需要查询整个老年代以确定是否可以清理回收，这显然是低效的。解决的方法是，年老代中维护一个512 byte的块——”card table“，所有老年代对象引用新生代对象的记录都记录在这里。Young GC时，只要查这里即可，不用再去查全部老年代，因此性能大大提高。</p>
<p style="margin:10px auto;text-indent:0px;padding:0px;line-height:1.5;"><a name="GCScheama" style="margin:0px;padding:0px;"></a><strong style="margin:0px;padding:0px;">Java GC机制</strong></p>
<p style="margin:10px auto;text-indent:0px;padding:0px;line-height:1.5;">GC机制的基本算法是：分代收集，这个不用赘述。下面阐述每个分代的收集方法。</p>
<p style="margin:10px auto;text-indent:0px;padding:0px;line-height:1.5;">　　</p>
<div style="margin:0px;padding:0px;line-height:1.5;">
<div style="margin:0px;padding:0px;line-height:1.5;">
<p style="margin:10px auto;text-indent:0px;padding:0px;line-height:1.5;"><strong style="margin:0px;padding:0px;">　　年轻代：</strong></p>
<p style="margin:10px auto;text-indent:0px;padding:0px;line-height:1.5;">　　事实上，在上一节，已经介绍了新生代的主要垃圾回收方法，在新生代中，使用“停止-复制”算法进行清理，将新生代内存分为2部分，1部分 Eden区较大，1部分Survivor比较小，并被划分为两个等量的部分。每次进行清理时，将Eden区和一个Survivor中仍然存活的对象拷贝到 另一个Survivor中，然后清理掉Eden和刚才的Survivor。</p>
<p style="margin:10px auto;text-indent:0px;padding:0px;line-height:1.5;">　　<span style="margin:0px;padding:0px;color:#ff0000;">这里也可以发现，停止复制算法中，用来复制的两部分并不总是相等的（传统的停止复制算法两部分内存相等，但新生代中使用1个大的Eden区和2个小的Survivor区来避免这个问题）</span></p>
<p style="margin:10px auto;text-indent:0px;padding:0px;line-height:1.5;">　　由于绝大部分的对象都是短命的，甚至存活不到Survivor中，所以，Eden区与Survivor的比例较大，HotSpot默认是 8:1，即分别占新生代的80%，10%，10%。如果一次回收中，Survivor+Eden中存活下来的内存超过了10%，则需要将一部分对象分配到 老年代。<span style="margin:0px;padding:0px;color:#2d4fc9;">用-XX:SurvivorRatio参数来配置Eden区域Survivor区的容量比值，默认是8，代表Eden：Survivor1：Survivor2=8:1:1.</span></p>
<p style="margin:10px auto;text-indent:0px;padding:0px;line-height:1.5;">　　<strong style="margin:0px;padding:0px;">老年代：</strong></p>
<div style="margin:0px;padding:0px;line-height:1.5;">　　老年代存储的对象比年轻代多得多，而且不乏大对象，对老年代进行内存清理时，如果使用停止-复制算法，则相当低效。一般，老年代用的算法是标记-整理算法，即：标记出仍然存活的对象（存在引用的），将所有存活的对象向一端移动，以保证内存的连续。</div>
<div style="margin:0px;padding:0px;line-height:1.5;">     在发生Minor GC时，虚拟机会检查每次晋升进入老年代的大小是否大于老年代的剩余空间大小，如果大于，则直接触发一次Full GC，否则，就查看是否<span style="margin:0px;padding:0px;color:#2d4fc9;">设置了-XX:+HandlePromotionFailure（允许担保失败），如果允许，则只会进行MinorGC，此时可以容忍内存分配失败；如果不允许，则仍然进行Full GC（这代表着如果设置-XX:+Handle PromotionFailure，则触发MinorGC就会同时触发Full GC，哪怕老年代还有很多内存，所以，最好不要这样做）。</span></div>
<p style="margin:10px auto;text-indent:0px;padding:0px;line-height:1.5;">　　<strong style="margin:0px;padding:0px;">方法区（永久代）：</strong></p>
<p style="margin:10px auto;text-indent:0px;padding:0px;line-height:1.5;">　　永久代的回收有两种：常量池中的常量，无用的类信息，常量的回收很简单，没有引用了就可以被回收。对于无用的类进行回收，必须保证3点：</p>
<ol style="padding-left:40px;margin:0px;padding:0px;">
<li style="list-style-type:decimal;margin:0px;padding:0px;list-style:none;margin-bottom:1em;">类的所有实例都已经被回收</li>
<li style="list-style-type:decimal;margin:0px;padding:0px;list-style:none;margin-bottom:1em;">加载类的ClassLoader已经被回收</li>
<li style="list-style-type:decimal;margin:0px;padding:0px;list-style:none;margin-bottom:1em;">类对象的Class对象没有被引用（即没有通过反射引用该类的地方）</li>
</ol>     永久代的回收并不是必须的，可以通过参数来设置是否对类进行回收。<span style="margin:0px;padding:0px;color:#2d4fc9;">HotSpot提供-Xnoclassgc进行控制</span></div>
<div style="margin:0px;padding:0px;line-height:1.5;"><span style="margin:0px;padding:0px;color:#2d4fc9;">     使用-verbose，-XX:+TraceClassLoading、-XX:+TraceClassUnLoading可以查看类加载和卸载信息</span></div>
<div style="margin:0px;padding:0px;line-height:1.5;"><span style="margin:0px;padding:0px;color:#2d4fc9;">     -verbose、-XX:+TraceClassLoading可以在Product版HotSpot中使用；</span></div>
<div style="margin:0px;padding:0px;line-height:1.5;"><span style="margin:0px;padding:0px;color:#2d4fc9;">     -XX:+TraceClassUnLoading需要fastdebug版HotSpot支持</span></div>
</div>
<p style="margin:10px auto;text-indent:0px;padding:0px;line-height:1.5;"><a name="GCparam" style="margin:0px;padding:0px;"></a><strong style="margin:0px;padding:0px;">垃圾收集器</strong></p>
<p style="margin:10px auto;text-indent:0px;padding:0px;line-height:1.5;">在GC机制中，起重要作用的是垃圾收集器，垃圾收集器是GC的具体实现，Java虚拟机规范中对于垃圾收集器没有任何规定，所以不同厂商实现的垃圾 收集器各不相同，HotSpot 1.6版使用的垃圾收集器如下图（图来源于《深入理解Java虚拟机：JVM高级特效与最佳实现》，图中两个收集器之间有连线，说明它们可以配合使用）：</p>
<p style="margin:10px auto;text-indent:0px;padding:0px;line-height:1.5;">　　<img src="Java系列笔记(3) - Java 内存区域和GC机制 - Daniel·广 - 博客园_files/23225652-8fe6831475f9437b91ff1e9d4fa9fabb.jpg" type="image/jpeg" data-filename="23225652-8fe6831475f9437b91ff1e9d4fa9fabb.jpg" height="527" style="border:0px;max-width:300px;height:auto;margin:0px;padding:0px;" width="508"/></p>
<p style="margin:10px auto;text-indent:0px;padding:0px;line-height:1.5;"><span style="margin:0px;padding:0px;color:#ff0000;">　　</span></p>
<div style="margin:0px;padding:0px;line-height:1.5;">
<div style="margin:0px;padding:0px;line-height:1.5;">
<p style="margin:10px auto;text-indent:0px;padding:0px;line-height:1.5;"><span style="margin:0px;padding:0px;color:#ff0000;">在介绍垃圾收集器之前，需要明确一点，就是在新生代采用的停止复制算法中，“停 止（Stop-the-world）”的意义是在回收内存时，需要暂停其他所 有线程的执行。这个是很低效的，现在的各种新生代收集器越来越优化这一点，但仍然只是将停止的时间变短，并未彻底取消停止。</span></p>
<ul style="margin-left:30px;padding-left:0px;margin:0px;padding:0px;word-break:break-all;">
<li style="list-style-type:disc;margin:0px;padding:0px;list-style:none;margin-bottom:1em;">Serial收集器：新生代收集器，使用停止复制算法，使用一个线程进行GC，串行，其它工作线程暂停。<span style="margin:0px;padding:0px;color:#2d4fc9;">使用-XX:+UseSerialGC可以使用Serial+Serial Old模式运行进行内存回收（这也是虚拟机在Client模式下运行的默认值）</span></li>
<li style="list-style-type:disc;margin:0px;padding:0px;list-style:none;margin-bottom:1em;">ParNew收集器：新生代收集器，使用停止复制算法，Serial收集器的多线程版，用多个线程进行GC，并行，其它工作线程暂停，关注缩短垃圾收集时间。<span style="margin:0px;padding:0px;color:#2d4fc9;">使用-XX:+UseParNewGC开关来控制使用ParNew+Serial Old收集器组合收集内存；使用-XX:ParallelGCThreads来设置执行内存回收的线程数。</span></li>
<li style="list-style-type:disc;margin:0px;padding:0px;list-style:none;margin-bottom:1em;">Parallel Scavenge 收集器：新生代收集器，使用停止复制算法，关注CPU吞吐量，即运行用户代码的时间/总时间，比如：JVM运行100分钟，其中运行用户代码99分钟，垃 圾收集1分钟，则吞吐量是99%，这种收集器能最高效率的利用CPU，适合运行后台运算（关注缩短垃圾收集时间的收集器，如CMS，等待时间很少，所以适 合用户交互，提高用户体验）。<span style="margin:0px;padding:0px;color:#2d4fc9;"><span style="margin:0px;padding:0px;color:#2d4fc9;">使用-XX:+UseParallelGC开关控制使用Parallel Scavenge+Serial Old收集器组合回收垃圾（这也是在Server模式下的默认值）；使用-XX:GCTimeRatio来设置用户执行时间占总时间的比例，默认99，即1%的时间用来进行垃圾回收。使用-XX:MaxGCPauseMillis设置GC的最大停顿时间（这个参数只对Parallel Scavenge有效），用开关参数-XX:+UseAdaptiveSizePolicy可以进行动态控制，如自动调整Eden/Survivor比例，老年代对象年龄，新生代大小等，这个参数在ParNew下没有。</span></span></li>
</ul>
<ul style="margin-left:30px;padding-left:0px;margin:0px;padding:0px;word-break:break-all;">
<li style="list-style-type:disc;margin:0px;padding:0px;list-style:none;margin-bottom:1em;">Serial Old收集器：老年代收集器，单线程收集器，串行，使用标记整理（整理的方法是Sweep（清理）和Compact（压缩），清理是将废弃的对象干掉，只留幸存的对象，压缩是将移动对象，将空间填满保证内存分为2块，一块全是对象，一块空闲）算法，使用单线程进行GC，其它工作线程暂停（注意，在老年代中进行标记整理算法清理，也需要暂停其它线程），在JDK1.5之前，Serial Old收集器与ParallelScavenge搭配使用。</li>
<li style="list-style-type:disc;margin:0px;padding:0px;list-style:none;margin-bottom:1em;">Parallel Old收集器：老年代收集器，多线程，并行，多线程机制与Parallel Scavenge差不错，使用标记整理（与Serial Old不同，这里的整理是Summary（汇总）和Compact（压缩），汇总的意思就是将幸存的对象复制到预先准备好的区域，而不是像Sweep（清理）那样清理废弃的对象）算法，在Parallel Old执行时，仍然需要暂停其它线程。Parallel Old在多核计算中很有用。Parallel Old出现后（JDK 1.6），与Parallel Scavenge配合有很好的效果，充分体现Parallel Scavenge收集器吞吐量优先的效果。<span style="margin:0px;padding:0px;color:#2d4fc9;">使用-XX:+UseParallelOldGC开关控制使用Parallel Scavenge +Parallel Old组合收集器进行收集。</span></li>
<li style="list-style-type:disc;margin:0px;padding:0px;list-style:none;margin-bottom:1em;">CMS（Concurrent Mark Sweep）收集器：老年代收集器，致力于获取最短回收停顿时间（即缩短垃圾回收的时间），使用标记清除算法，多线程，优点是并发收集（用户线程可以和GC线程同时工作），停顿小。<span style="margin:0px;padding:0px;color:#2d4fc9;">使用-XX:+UseConcMarkSweepGC进行ParNew+CMS+Serial Old进行内存回收，优先使用ParNew+CMS（原因见后面），当用户线程内存不足时，采用备用方案Serial Old收集。</span></li>
</ul>
</div>
<blockquote style="background:url(images/comment.gif) 25px 0px no-repeat;border:2px solid rgb(239, 239, 239);padding:10px 60px 5px;margin-top:10px;margin-bottom:10px;margin:0px;min-height:35px;line-height:1.6em;color:rgb(51, 51, 51);">
<div style="margin:0px;padding:0px;line-height:1.5;">
<div style="margin:0px;padding:0px;line-height:1.5;">CMS收集的执行过程是：初始标记(CMS-initial-mark) -&gt; 并发标记(CMS-concurrent-mark) --&gt;预清理(CMS-concurrent-preclean)--&gt;可控预清理(CMS-concurrent-abortable-preclean)-&gt; 重新标记(CMS-remark) -&gt; 并发清除(CMS-concurrent-sweep) -&gt;并发重设状态等待下次CMS的触发(CMS-concurrent-reset)</div>
<div style="margin:0px;padding:0px;line-height:1.5;">具体的说，先2次标记，1次预清理，1次重新标记，再1次清除。 </div>
<div style="margin:0px;padding:0px;line-height:1.5;">
<div style="margin:0px;padding:0px;line-height:1.5;">1，首先jvm根据<span style="margin:0px;padding:0px;color:#0000ff;">-XX:CMSInitiatingOccupancyFraction</span>，<span style="margin:0px;padding:0px;color:#0000ff;">-XX:+UseCMSInitiatingOccupancyOnly</span>来决定什么时间开始垃圾收集；</div>
<div style="margin:0px;padding:0px;line-height:1.5;">2，如果设置了<span style="margin:0px;padding:0px;color:#0000ff;">-XX:+UseCMSInitiatingOccupancyOnly</span>，那么只有当old代占用确实达到了-XX:CMSInitiatingOccupancyFraction参数所设定的比例时才会触发cms gc；</div>
<div style="margin:0px;padding:0px;line-height:1.5;">3，如果没有设置<span style="margin:0px;padding:0px;color:#0000ff;">-XX:+UseCMSInitiatingOccupancyOnly</span>，那么系统会根据统计数据自行决定什么时候触发cms gc；因此有时会遇到设置了80%比例才cms gc，但是50%时就已经触发了，就是因为这个参数没有设置的原因；</div>
<div style="margin:0px;padding:0px;line-height:1.5;">4，当cms gc开始时，首先的阶段是初始标记(CMS-initial-mark)，是stop the world阶段，因此此阶段标记的对象只是从root集最直接可达的对象；</div>
<div style="margin:0px;padding:0px;line-height:1.5;">     CMS-initial-mark：961330K（1572864K），指标记时，old代的已用空间和总空间</div>
<div style="margin:0px;padding:0px;line-height:1.5;">5，下一个阶段是并发标记(CMS-concurrent-mark)，此阶段是和应用线程并发执行的，所谓并发收集器指的就是这个，主要作用是标记可达的对象，此阶段不需要用户停顿。</div>
<div style="margin:0px;padding:0px;line-height:1.5;">       此阶段会打印2条日志：CMS-concurrent-mark-start，CMS-concurrent-mark</div>
<div style="margin:0px;padding:0px;line-height:1.5;">6，下一个阶段是CMS-concurrent-preclean，此阶段主要是进行一些预清理，因为标记和应用线程是并发执行的，因此会有些对象的状态在标记后会改变，此阶段正是解决这个问题因为之后的Rescan阶段也会stop the world，为了使暂停的时间尽可能的小，也需要preclean阶段先做一部分工作以节省时间</div>
<div style="margin:0px;padding:0px;line-height:1.5;">     此阶段会打印2条日志：CMS-concurrent-preclean-start，CMS-concurrent-preclean</div>
<div style="margin:0px;padding:0px;line-height:1.5;">7，下一阶段是CMS-concurrent-abortable-preclean阶段，加入此阶段的目的是使cms gc更加可控一些，作用也是执行一些预清理，以减少Rescan阶段造成应用暂停的时间</div>
<div style="margin:0px;padding:0px;line-height:1.5;">     此阶段涉及几个参数：</div>
<div style="margin:0px;padding:0px;line-height:1.5;">    <span style="margin:0px;padding:0px;color:#0000ff;"> -XX:CMSMaxAbortablePrecleanTime</span>：当abortable-preclean阶段执行达到这个时间时才会结束</div>
<div style="margin:0px;padding:0px;line-height:1.5;">     <span style="margin:0px;padding:0px;color:#0000ff;">-XX:CMSScheduleRemarkEdenSizeThreshold</span>（默认2m）：控制abortable-preclean阶段什么时候开始执行，</div>
<div style="margin:0px;padding:0px;line-height:1.5;">      即当eden使用达到此值时，才会开始abortable-preclean阶段</div>
<div style="margin:0px;padding:0px;line-height:1.5;">     <span style="margin:0px;padding:0px;color:#0000ff;">-XX:CMSScheduleRemarkEdenPenetratio</span>（默认50%）：控制abortable-preclean阶段什么时候结束执行</div>
<div style="margin:0px;padding:0px;line-height:1.5;">      此阶段会打印一些日志如下：</div>
<div style="margin:0px;padding:0px;line-height:1.5;">     CMS-concurrent-abortable-preclean-start，CMS-concurrent-abortable-preclean，</div>
<div style="margin:0px;padding:0px;line-height:1.5;">      CMS：abort preclean due to time XXX</div>
<div style="margin:0px;padding:0px;line-height:1.5;">8，再下一个阶段是第二个stop the world阶段了，即Rescan阶段，此阶段暂停应用线程，停顿时间比并发标记小得多，但比初始标记稍长。对对象进行重新扫描并标记；</div>
<div style="margin:0px;padding:0px;line-height:1.5;">       YG occupancy：964861K（2403008K），指执行时young代的情况</div>
<div style="margin:0px;padding:0px;line-height:1.5;">       CMS remark：961330K（1572864K），指执行时old代的情况</div>
<div style="margin:0px;padding:0px;line-height:1.5;">      此外，还打印出了弱引用处理、类卸载等过程的耗时</div>
<div style="margin:0px;padding:0px;line-height:1.5;">9，再下一个阶段是CMS-concurrent-sweep，进行并发的垃圾清理</div>
<div style="margin:0px;padding:0px;line-height:1.5;">10，最后是CMS-concurrent-reset，为下一次cms gc重置相关数据结构</div>
<div style="margin:0px;padding:0px;line-height:1.5;"> </div>
<div style="margin:0px;padding:0px;line-height:1.5;">有2种情况会触发CMS 的悲观full gc，在悲观full gc时，整个应用会暂停</div>
<div style="margin:0px;padding:0px;line-height:1.5;">       A，concurrent-mode-failure：预清理阶段可能出现，当cms gc正进行时，此时有新的对象要进行old代，但是old代空间不足造成的。其可能性有：1，O区空间不足以让新生代晋级，2，O区空间用完之前，无法完成对无引用的对象的清理。这表明，当前有大量数据进入内存且无法释放。</div>
<div style="margin:0px;padding:0px;line-height:1.5;">       B，promotion-failed：新生代young gc可能出现，当进行young gc时，有部分young代对象仍然可用，但是S1或S2放不下，因此需要放到old代，但此时old代空间无法容纳此。</div>
<div style="margin:0px;padding:0px;line-height:1.5;"> </div>
<div style="margin:0px;padding:0px;line-height:1.5;">影响cms gc时长及触发的参数是以下2个：</div>
<div style="margin:0px;padding:0px;line-height:1.5;">        <span style="margin:0px;padding:0px;color:#0000ff;">-XX:CMSMaxAbortablePrecleanTime=5000</span></div>
<div style="margin:0px;padding:0px;line-height:1.5;">        <span style="margin:0px;padding:0px;color:#0000ff;">-XX:CMSInitiatingOccupancyFraction=80</span></div>
<div style="margin:0px;padding:0px;line-height:1.5;">解决也是针对这两个参数来的，根本的原因是每次请求消耗的内存量过大</div>
<div style="margin:0px;padding:0px;line-height:1.5;">解决方式：</div>
<div style="margin:0px;padding:0px;line-height:1.5;">      A，针对cms gc的触发阶段，调整<span style="margin:0px;padding:0px;color:#0000ff;">-XX:CMSInitiatingOccupancyFraction=50</span>，提早触发cms gc，就可以缓解当old代达到80%，cms gc处理不完，从而造成concurrent mode failure引发full gc</div>
<div style="margin:0px;padding:0px;line-height:1.5;">     B，修改-XX:CMSMaxAbortablePrecleanTime=500，缩小CMS-concurrent-abortable-preclean阶段的时间</div>
<div style="margin:0px;padding:0px;line-height:1.5;">     C，考虑到cms gc时不会进行compact，因此加入<span style="margin:0px;padding:0px;color:#0000ff;">-XX:+UseCMSCompactAtFullCollection</span></div>
<div style="margin:0px;padding:0px;line-height:1.5;">       （cms gc后会进行内存的compact）和<span style="margin:0px;padding:0px;color:#0000ff;">-XX:CMSFullGCsBeforeCompaction=4</span>（在full gc4次后会进行compact）参数</div>
</div>
<div style="margin:0px;padding:0px;line-height:1.5;"> </div>
<div style="margin:0px;padding:0px;line-height:1.5;">在CMS清理过程中，只有初始标记和重新标记需要短暂停顿，并发标记和并发清除都不需要暂停用户线程，因此效率很高，很适合高交互的场合。</div>
<div style="margin:0px;padding:0px;line-height:1.5;">CMS也有缺点，它需要消耗额外的CPU和内存资源，在CPU和内存资源紧张，CPU较少时，会加重系统负担（CMS默认启动线程数为(CPU数量+3)/4）。</div>
<div style="margin:0px;padding:0px;line-height:1.5;">另外，在并发收集过程中，用户线程仍然在运行，仍然产生内存垃圾，所以可能产生“浮动垃圾”，本次无法清理，只能下一次Full GC才清理，因此在GC期间，需要预留足够的内存给用户线程使用。所以使用CMS的收集器并不是老年代满了才触发Full GC，而是在使用了一大半（默认68%，即2/3，使用-XX:CMSInitiatingOccupancyFraction来设置）的时候就要进行Full GC，如果用户线程消耗内存不是特别大，可以适当调高-XX:CMSInitiatingOccupancyFraction以降低GC次数，提高性能，如果预留的用户线程内存不够，则会触发Concurrent Mode Failure，此时，将触发备用方案：使用Serial Old 收集器进行收集，但这样停顿时间就长了，因此-XX:CMSInitiatingOccupancyFraction不宜设的过大。</div>
<div style="margin:0px;padding:0px;line-height:1.5;">还有，CMS采用的是标记清除算法，会导致内存碎片的产生，可以使用-XX：+UseCMSCompactAtFullCollection来设置是否在Full GC之后进行碎片整理，用-XX：CMSFullGCsBeforeCompaction来设置在执行多少次不压缩的Full GC之后，来一次带压缩的Full GC。</div>
</div>
</blockquote>
<ul style="margin-left:30px;padding-left:0px;margin:0px;padding:0px;word-break:break-all;">
<li style="list-style-type:disc;margin:0px;padding:0px;list-style:none;margin-bottom:1em;">G1收集器：在JDK1.7中正式发布，与现状的新生代、老年代概念有很大不同，目前使用较少，不做介绍。</li>
</ul>
<div style="margin:0px;padding:0px;line-height:1.5;">
<div style="margin:0px;padding:0px;line-height:1.5;"> </div>
<div style="margin:0px;padding:0px;line-height:1.5;"><span style="margin:0px;padding:0px;color:#ff0000;">     </span><span style="margin:0px;padding:0px;color:#ff0000;">注意并发（Concurrent）和并行（Parallel）的区别：</span></div>
<div style="margin:0px;padding:0px;line-height:1.5;"><span style="margin:0px;padding:0px;color:#ff0000;"><strong style="margin:0px;padding:0px;">     </strong></span><span style="margin:0px;padding:0px;color:#ff0000;"><strong style="margin:0px;padding:0px;">并发</strong>是指用户线程与GC线程同时执行（不一定是并行，可能交替，但总体上是在同时执行的），不需要停顿用户线程（其实在CMS中用户线程还是需要停顿的，只是非常短，GC线程在另一个CPU上执行）；</span></div>
<div style="margin:0px;padding:0px;line-height:1.5;"><span style="margin:0px;padding:0px;color:#ff0000;"><strong style="margin:0px;padding:0px;">     </strong></span><span style="margin:0px;padding:0px;color:#ff0000;"><strong style="margin:0px;padding:0px;">并行</strong>收集是指多个GC线程并行工作，但此时用户线程是暂停的；</span></div>
<div style="margin:0px;padding:0px;line-height:1.5;"><span style="margin:0px;padding:0px;color:#ff0000;">所以，Serial是串行的，Parallel收集器是并行的，而CMS收集器是并发的.</span></div>
<div style="margin:0px;padding:0px;line-height:1.5;"> </div>
<div style="margin:0px;padding:0px;line-height:1.5;"><strong style="margin:0px;padding:0px;"><span style="margin:0px;padding:0px;color:#ff0000;">关于JVM参数配置和内存调优实例，见我的下一篇博客（编写中：Java系列笔记(4) - JVM监控与调优），本来想写在同一篇博客里的，无奈内容太多，只好另起一篇。</span></strong></div>
<div style="margin:0px;padding:0px;line-height:1.5;"> </div>
<div style="margin:0px;padding:0px;line-height:1.5;"><strong style="margin:0px;padding:0px;"><span style="margin:0px;padding:0px;color:#000000;">说明：</span></strong></div>
<div style="margin:0px;padding:0px;line-height:1.5;"><span style="margin:0px;padding:0px;color:#000000;">　　本文是Java系列笔记的第3篇，这篇文章写了很久，主要是Java内存和GC机制相对复杂，难以理解，加上本人这段时间项目和生活中耗费的时间很多，所以进度缓慢。文中大多数笔记内容来源于我在网络上查到的博客和《深入理解Java虚拟机：JVM高级特效与最佳实现》一书。</span></div>
<div style="margin:0px;padding:0px;line-height:1.5;">　　本人能力有限，如果有错漏，请留言指正。</div>
<div style="margin:0px;padding:0px;line-height:1.5;"><strong style="margin:0px;padding:0px;"><span style="margin:0px;padding:0px;color:#000000;">参考资料：</span></strong></div>
<div style="margin:0px;padding:0px;line-height:1.5;"><span style="margin:0px;padding:0px;color:#000000;">《JAVA编程思想》，第5章；</span></div>
<div style="margin:0px;padding:0px;line-height:1.5;"><span style="margin:0px;padding:0px;color:#000000;">《Java深度历险》，Java垃圾回收机制与引用类型；</span></div>
<div style="margin:0px;padding:0px;line-height:1.5;"><span style="margin:0px;padding:0px;color:#000000;"><span style="margin:0px;padding:0px;color:#000000;">《深入理解Java虚拟机：JVM高级特效与最佳实现》</span>，第2-3章；</span></div>
<div style="margin:0px;padding:0px;line-height:1.5;"><span style="margin:0px;padding:0px;color:#000000;">成为JavaGC专家Part II — 如何监控Java垃圾回收机制, http://www.importnew.com/2057.html</span></div>
<div style="margin:0px;padding:0px;line-height:1.5;"><span style="margin:0px;padding:0px;color:#000000;">JDK5.0垃圾收集优化之--Don't Pause,http://calvin.iteye.com/blog/91905</span></div>
<div style="margin:0px;padding:0px;line-height:1.5;"><span style="margin:0px;padding:0px;color:#000000;">【原】java内存区域理解-初步了解，http://iamzhongyong.iteye.com/blog/1333100</span></div>
<div style="margin:0px;padding:0px;line-height:1.5;">
<div style="margin:0px;padding:0px;line-height:1.5;"> 关于施用full gc频繁的分析及解决：http://www.07net01.com/zhishi/383213.html</div>
</div>
</div>
</div>
<p style="margin:10px auto;text-indent:0px;padding:0px;line-height:1.5;"> </p></div>
<div style="clear:both;margin:0px;padding:0px;"></div>
<div style="margin-top:20px;margin:0px;padding:0px;">
<div style="margin-bottom:10px;margin:0px;padding:0px;">分类: <a href="https://www.cnblogs.com/zhguang/category/482328.html" style="margin:0px;padding:0px;color:rgb(68, 68, 68);text-decoration:underline;" target="_blank">Java Core</a></div>
<div style="margin-top:0px;font-size:9pt;color:gray;margin:0px;padding:0px;">标签: <a href="https://www.cnblogs.com/zhguang/tag/Java/" style="margin:0px;padding:0px;color:rgb(102, 102, 102);text-decoration:underline;margin-left:5px;">Java</a>, <a href="https://www.cnblogs.com/zhguang/tag/GC/" style="margin:0px;padding:0px;color:rgb(102, 102, 102);text-decoration:underline;margin-left:5px;">GC</a>, <a href="https://www.cnblogs.com/zhguang/tag/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" style="margin:0px;padding:0px;color:rgb(102, 102, 102);text-decoration:underline;margin-left:5px;">垃圾回收</a>, <a href="https://www.cnblogs.com/zhguang/tag/%E8%99%9A%E6%8B%9F%E6%9C%BA/" style="margin:0px;padding:0px;color:rgb(102, 102, 102);text-decoration:underline;margin-left:5px;">虚拟机</a>, <a href="https://www.cnblogs.com/zhguang/tag/%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/" style="margin:0px;padding:0px;color:rgb(102, 102, 102);text-decoration:underline;margin-left:5px;">内存机制</a></div>
<div style="margin:0px;padding:0px;"><div style="padding:10px 0px;margin-bottom:10px;margin-top:10px;border:1px dashed silver;font-size:12px;width:320px;text-align:center;margin:0px;">
        <a href="#" style="background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAAkCAYAAABIdFAMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAHhJREFUeNo8zjsOxCAMBFB/KEAUFFR0Cbng3nQPw68ArZdAlOZppPFIBhH5EAB8b+Tlt9MYQ6i1BuqFaq1CKSVcxZ2Acs6406KUgpt5/LCKuVgz5BDCSb13ZO99ZOdcZGvt4mJjzMVKqcha68iIePB86GAiOv8CDADlIUQBs7MD3wAAAABJRU5ErkJggg%3D%3D) repeat-x;display:inline-block;padding:3px 8px;color:rgb(255, 255, 255);text-decoration:none;font-weight:bold;cursor:pointer;margin-right:10px;border-radius:10px;box-shadow:rgba(0, 0, 0, 0.5) 0px 1px 3px;text-shadow:rgba(0, 0, 0, 0.25) 0px -1px 1px;vertical-align:middle;background-color:rgb(45, 174, 191);border:none;margin:0px;">好文要顶</a>
            <a href="#" style="background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAAkCAYAAABIdFAMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAHhJREFUeNo8zjsOxCAMBFB/KEAUFFR0Cbng3nQPw68ArZdAlOZppPFIBhH5EAB8b+Tlt9MYQ6i1BuqFaq1CKSVcxZ2Acs6406KUgpt5/LCKuVgz5BDCSb13ZO99ZOdcZGvt4mJjzMVKqcha68iIePB86GAiOv8CDADlIUQBs7MD3wAAAABJRU5ErkJggg%3D%3D) repeat-x;display:inline-block;padding:3px 8px;color:rgb(255, 255, 255);text-decoration:none;font-weight:bold;cursor:pointer;margin-right:10px;border-radius:10px;box-shadow:rgba(0, 0, 0, 0.5) 0px 1px 3px;text-shadow:rgba(0, 0, 0, 0.25) 0px -1px 1px;vertical-align:middle;background-color:rgb(227, 49, 0);border:none;margin:0px;">关注我</a>
    <a href="#" style="background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAAkCAYAAABIdFAMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAHhJREFUeNo8zjsOxCAMBFB/KEAUFFR0Cbng3nQPw68ArZdAlOZppPFIBhH5EAB8b+Tlt9MYQ6i1BuqFaq1CKSVcxZ2Acs6406KUgpt5/LCKuVgz5BDCSb13ZO99ZOdcZGvt4mJjzMVKqcha68iIePB86GAiOv8CDADlIUQBs7MD3wAAAABJRU5ErkJggg%3D%3D) repeat-x;display:inline-block;padding:3px 8px;color:rgb(255, 255, 255);text-decoration:none;font-weight:bold;cursor:pointer;margin-right:10px;border-radius:10px;box-shadow:rgba(0, 0, 0, 0.5) 0px 1px 3px;text-shadow:rgba(0, 0, 0, 0.25) 0px -1px 1px;vertical-align:middle;background-color:rgb(255, 181, 21);border:none;margin:0px;">收藏该文</a>
    <a href="#" style="background:none;display:inline-block;padding:3px 2px;color:rgb(255, 255, 255);text-decoration:none;font-weight:bold;cursor:pointer;margin-right:10px;border-radius:10px;box-shadow:none;text-shadow:none;vertical-align:middle;border:none;margin:0px;" title="分享至新浪微博"><img src="Java系列笔记(3) - Java 内存区域和GC机制 - Daniel·广 - 博客园_files/icon_weibo_24.png" type="image/png" data-filename="icon_weibo_24.png" height="24" style="border:none;vertical-align:middle;margin-left:5px;box-shadow:none;margin:0px;padding:0px;height:auto;max-width:300px;" width="24"/></a>
    <a href="#" style="background:none;display:inline-block;padding:3px 2px;color:rgb(255, 255, 255);text-decoration:none;font-weight:bold;cursor:pointer;margin-right:10px;border-radius:10px;box-shadow:none;text-shadow:none;vertical-align:middle;border:none;margin:0px;" title="分享至微信"><img src="Java系列笔记(3) - Java 内存区域和GC机制 - Daniel·广 - 博客园_files/wechat.png" type="image/png" data-filename="wechat.png" height="24" style="border:medium none;width:24px;height:24px;box-shadow:none;margin-left:5px;vertical-align:middle;margin:0px;padding:0px;max-width:300px;" width="24"/></a>
</div>
<div style="float:left;width:280px;margin-top:0px;margin-bottom:10px;color:rgb(0, 0, 0);margin-left:0px;font-size:12px;margin:0px;padding:0px;">
    <div style="float:left;line-height:18px;margin:0px;padding:0px;">
            <a href="http://home.cnblogs.com/u/zhguang/" style="margin:0px;padding:0px;color:rgb(68, 68, 68);text-decoration:underline;" target="_blank"><img src="Java系列笔记(3) - Java 内存区域和GC机制 - Daniel·广 - 博客园_files/u406312.jpg" type="image/jpeg" data-filename="u406312.jpg" height="48" style="border:0px;vertical-align:top;float:left;margin-right:5px;padding-top:5px;padding-left:2px;margin:0px;padding:0px;height:auto;max-width:300px;" width="48"/></a>
        <div style="float:left;line-height:18px;margin:0px;padding:0px;">
            <a href="http://home.cnblogs.com/u/zhguang/" style="margin:0px;padding:0px;color:rgb(68, 68, 68);text-decoration:underline;">Daniel·广</a><br style="margin:0px;padding:0px;"/>
            <a href="http://home.cnblogs.com/u/zhguang/followees" style="margin:0px;padding:0px;color:rgb(68, 68, 68);text-decoration:underline;">关注 - 0</a><br style="margin:0px;padding:0px;"/>
            <a href="http://home.cnblogs.com/u/zhguang/followers" style="margin:0px;padding:0px;color:rgb(68, 68, 68);text-decoration:underline;">粉丝 - 163</a>
        </div>
    </div>
    <div style="clear:both;margin:0px;padding:0px;"></div>
    <div style="margin:0px;padding:0px;"></div>
    <div style="margin:0px;padding:0px;">
                <a href="#" style="margin:0px;padding:0px;color:rgb(68, 68, 68);text-decoration:underline;">+加关注</a>
    </div>
</div>
<div style="float:right;margin-bottom:10px;margin-right:30px;font-size:12px;width:125px;text-align:center;margin-top:10px;margin:0px;padding:0px;">
    <div style="float:left;width:46px;height:52px;background:url(//static.cnblogs.com/images/upup.gif) no-repeat;text-align:center;cursor:pointer;margin-top:2px;padding-top:5px;margin:0px;padding:0px;">
        <span style="font-size:14px;color:rgb(7, 93, 179);font-family:Verdana;line-height:1.5em;margin:0px;padding:0px;">33</span>
    </div>
    <div style="float:right;margin-left:20px;width:46px;height:52px;background:url(//static.cnblogs.com/images/downdown.gif) no-repeat;text-align:center;cursor:pointer;margin-top:2px;padding-top:5px;margin:0px;padding:0px;">
        <span style="font-size:14px;color:rgb(7, 93, 179);font-family:Verdana;line-height:1.5em;margin:0px;padding:0px;">0</span>
    </div>
    <div style="clear:both;margin:0px;padding:0px;"></div>
    <div style="margin-top:5px;margin-left:0px;font-size:12px;color:gray;margin:0px;padding:0px;">
    </div>
</div>
</div>
<div style="clear:both;margin:0px;padding:0px;"></div>
<div style="line-height:1.8;font-size:12px;margin:0px;padding:0px;"><a href="https://www.cnblogs.com/zhguang/p/3091378.html" style="text-decoration:none;margin:0px;padding:0px;color:rgb(68, 68, 68);">« </a> 上一篇：<a href="https://www.cnblogs.com/zhguang/p/3091378.html" style="margin:0px;padding:0px;color:rgb(68, 68, 68);text-decoration:underline;" title="发布于2013-07-02 22:10">Java系列笔记(2) - Java RTTI和反射机制</a><br style="margin:0px;padding:0px;"/><a href="https://www.cnblogs.com/zhguang/p/Java-JVM-GC.html" style="text-decoration:none;margin:0px;padding:0px;color:rgb(68, 68, 68);">» </a> 下一篇：<a href="https://www.cnblogs.com/zhguang/p/Java-JVM-GC.html" style="margin:0px;padding:0px;color:rgb(68, 68, 68);text-decoration:underline;" title="发布于2013-12-31 18:18">Java系列笔记(4) - JVM监控与调优</a><br style="margin:0px;padding:0px;"/></div>
</div>


		</div>
		<div style="margin:0px;padding:0px;float:right;width:100%;clear:both;text-align:right;padding-right:5px;color:rgb(168, 177, 186);margin-top:5px;">posted @ <span style="margin:0px;padding:0px;">2013-09-27 01:12</span> <a href="https://www.cnblogs.com/zhguang/" style="margin:0px;padding:0px;color:rgb(102, 102, 102);text-decoration:none;">Daniel·广</a> 阅读(<span style="margin:0px;padding:0px;">63972</span>) 评论(<span style="margin:0px;padding:0px;">41</span>)  <a href="https://i.cnblogs.com/EditPosts.aspx?postid=3257367" rel="nofollow" style="margin:0px;padding:0px;color:rgb(102, 102, 102);text-decoration:none;">编辑</a> <a href="https://www.cnblogs.com/zhguang/p/3257367.html#" style="margin:0px;padding:0px;color:rgb(102, 102, 102);text-decoration:none;">收藏</a></div>
	</div></div></div></div></div></div></div></div></div></div>
</div>
</span>
</div></body></html> 