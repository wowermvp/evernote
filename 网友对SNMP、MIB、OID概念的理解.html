<html>
<head>
  <title>网友对SNMP、MIB、OID概念的理解</title>
  <basefont face="宋体" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/600718 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 宋体;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1797"/>
<h1>网友对SNMP、MIB、OID概念的理解</h1>

<div>
<span style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><table align="center" border="0" cellpadding="0" cellspacing="0" style="font-family: 宋体; line-height: 18px; background-color: rgb(255, 255, 255);" width="100%"><tbody><tr><td align="middle" height="35" style="font-size: 9pt; word-break: break-all;"><b><font size="3">网友对SNMP、MIB、OID概念的理解</font></b></td></tr><tr><td style="font-size: 9pt; font-weight: bold; color: rgb(3, 127, 168); word-break: break-all;"></td></tr><tr><td align="middle" height="23" style="font-size: 9pt; background-color: rgb(245, 245, 245);"><font size="3"><br/></font></td></tr><tr><td height="6" style="font-size: 9pt;"></td></tr><tr><td height="300" style="font-size: 9pt;"><div style="float: left; margin: 0px; padding: 0px; border: 0px;"><font size="3"><ins style="display: inline-table; border: none; height: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; width: 0px; background-color: transparent;"><ins style="visibility: visible; display: block; height: 0px; margin: 0px; padding: 0px; position: relative; border: none; width: 0px; overflow: hidden; opacity: 0; background-color: transparent;"><div style="left: 0px; position: absolute; top: 0px;"><font size="3"><ins style="display: inline-table; border: none; height: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; width: 0px; background-color: transparent;"><ins style="display: inline-table; border: none; height: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; width: 0px; background-color: transparent;"><ins style="display: inline-table; border: none; height: 0px; margin: 0px; padding: 0px; position: relative; visibility: visible; width: 0px; background-color: transparent;"></ins></ins></ins></font></div></ins></ins> </font></div><font size="3">1.1. SNMP概览 <br/>
SNMP的基本知识介绍<br/>
简单网络管理协议（SNMP－Simple Network Management Protocol)是一个与网络设备交互的简单方法。该规范是由IETF在1990年五月发布的RFC 1157中定义的。SNMP通常被认为相当难懂，并且过于复杂，其可用的API似乎在本来非常简单的东西外面封装了大量的东西。现在关于SNMP的书籍又往往只是把它更加复杂化了，而没有解释清楚。<br/>
SNMP对于任何程序设计人员来说是特别易于理解的。总体的简化能够很好地把这个系统简化。一个网络设备以守护进程的方式运行SNMP代理，该守护进程能够响应来自网络的各种请求信息。该SNMP代理提供大量的对象标识符（OID－Object Identifiers）。一个OID是一个唯一的键值对。该代理存放这些值并让它们可用。一个SNMP管理器（客户）可以向代理查询键值对中的特定信息。从程序员的角度看，这和导入大量的全局变量没有多少区别。SNMP的OID是可读或可写的。尽管向一个SNMP设备写入信息的情况非常少，但它是各种管理应用程序用来控制设备的方法（例如针对交换机的可管理GUI）。SNMP中有一个基本的认证框架，能够让管理员发送公共名来对OID读取或写入的认证。绝大多数的设备使用不安全的公共名 &quot;public&quot; 。 SNMP协议通过UDP端口161和162进行通信的。<br/>
注意，我还没有提到MIB！MIB的重要性被大大地夸大了。刚开始时，MIB显得非常复杂，但是它们其实非常简单。OID是数字的和全局的键值对。一个OID看起来和一个IPv6的地址很象，并且不同的厂商有不同的前缀等信息。OID都非常长，使得人们难以记住，或者对他非常感冒。因此，人们就设计了一种将数字OID翻译为人们可读的格式。这种翻译映射被保存在一个被称为 “管理信息基础&quot;（Management Infomation Base) 或MIB的、可传递的无格式文本文件里。使用SNMP或者向SNMP设备查询，你不需要使用MIB，但是，如果没有MIB，你就得猜测你正在查看的数据是什么。某些情况下，不使用MIB也非常简单，例如查看主机名、磁盘使用率数字，或者端口状态信息。其他情况下，就非常困难了，这个时候使用MIB就非常有帮助。对于准备编写的应用程序来说，为了让用户避免妥当安装MIB带来的麻烦，而严格使用数字OID是并不是很少见的。<span style="color: rgb(128, 128, 0);">安装一个MIB的动作，只是将他放置到你的SNMP客户端应用软件能够搜索到并进行上述翻译映射工作的某个位置而已。<br/></span>SNMP可以按照两种方式来使用：轮询和陷阱。轮询就是说你编写一个应用程序能够设置一个发送给一个SNMP代理查看某些值的SNMP GET请求。这种方法非常有用，因为如果该设备响应了请求，你就得到了你需要的信息，如果该设备没有响应请求，你就能够知道存在某些问题。轮询是网络监控的一种主动形式。另一方面，<span style="color: rgb(128, 128, 0);">SNMP陷阱能够被用来进行被动形式的网络监控。SNMP陷阱是通过配置SNMP设备的代理，让他在某些动作发生时联系另一个SNMP代理来实现的</span>。<br/>
备，可以配置为在某些事件发生时发送SNMP陷阱。例如，你可以配置Cisco的IOS在某个独立事件（例如链路断开）发生时，或者在任何定义的陷阱事件发生时，发送SNMP陷阱。（IOS：snmp服务器开启了链路断开的snmp陷阱）。当陷阱事件发生时，设备中的snmp代理会发送该陷阱到一个预先配置好的通常成为陷阱主机的目标上。陷阱主机会运行有自己的SNMP代理，该代理能够接受并处理传入的陷阱。这些陷阱的处理由陷阱处理器来完成。陷阱处理器可以用任何语言编写，并且可以通过STDIN（标准输入）传入的来自发送陷阱的信息。该处理器之后可以根据陷阱进行任何想作的事情，例如发送邮件或者你想要的任何事情。<br/>
SNMP被广泛应用在NMS网络管理系统中（Network Management System）。知名的NMS包括BMC的Patrol、CA的Unicenter、Sun Mangegement控制台、IBM的Tivoli Netview、以及全球著名的HP Openview。NMS的目标是提供一个监控和管理所有开启SNMP功能的设备的单一入口。通过配置你的设备代理来接受写访问，你可以从一个应用程序中处理你的网络环境。如果你的整个环境围拢NMS解决方案架构你的环境，你就能无限制地控制、查看你的整个网络。尽管Net-SNMP提供了可用来构建你自己的NMS网管系统的所有工具，我们不会再进一步讨论关于NMS的话题。不过请记住，如果你认为你的SNMP设备厂商没有提供SNMP代理方面的详细信息，很可能是因为他们希望你购买他们的NMS网络管理系统，或者购买能够在另一个NMS平台上使用的插件。<br/>
1.2. SNMP的三大版本 <br/>
SNMP的常用版本有三个：SNMPv1、SNMPv2、SNMPv3<br/>
Three different version of SNMP exist: SNMPv1 (RFC’s 1155, 1157, and 1212), SNMPv2c (RFC’s 1901 through 1908), and SNMPv3 (RFC’s 3411 though 3418). The co-existence of all three versions are detailed in RFC 3584.SNMP有三个不同的版本：SNMPv1(RFC 1155、RFC 1157、RFC 1212),SNMPv2c (RFC 1901、1908）以及 SNMPv3 (RFC 3411 - 3418). RFC 3584中详细说明了这三种版本同时共存方面的信息。<br/>
SNMPv1 is the original standard for community based management. SNMPv2 was derived from the SNMPv1 framework but had no message definition, which was later revamped aa SNMPv2c, a community based version of SNMPv2 with a message format similar to SNMPv1. SNMPv2 added several new datatypes (Counter32, Counter64, Gauge32, UInteger32, NsapAdress, and BIT STRING), as well as enhancements to OID tables and the setting of OID values. SNMPv3 is an extensable SNMPv2 framework with a new message format, ACL and security abilities, and remote configuration of SNMP parameters.<br/><span style="color: rgb(0, 0, 255);">SNMPv1是为基于公共管理的初始标准。SNMPv2是SNMPv1框架下衍生出来的，但是没有定义信息，其后修订为SNMPv2c,一个带有于SNMPv1类似信息格式的给予公共管理的版本。SNMPv2添加了几个新的数据类型（Counter32、Counter64、Gauge32、UInteger32、NsapAdress 以及BIT STRING),以及对OID表和OID值的设置的增强。SNMPv3是一个带有新的信息格式、ACL、安全功能和远处SNMP参数配置的、扩展了SNMPv2框架的版本。</span><br/>
SNMP is based on several other standards including the Abstract Syntax Notation 1 Basic Encoding Rules (ASN.1 BER) which defines the SNMP used Datatypes and the Structure of Management Information (SMI) which details the grammar used by SNMP MIBs. SMI comes in two varieties: SMIv1 (RFC 1155) and SMIv2 (RFC 2578). SMIv1 is now obsolete and should not be used. If you choose to modify MIBs at some point you’ll need to learn SMIv2 and ASN.1 syntax, but otherwise they are interesting but unnecessary to learn.<br/><span style="color: rgb(0, 0, 255);">SNMP是基于几个其他规范的，包括定义给予SNMP的数据类型的ASN.1 BER(Abstract Syntax Notation 1 Basic Encoding Rules), 以及详细描述有SNMP MIB使用的语法的管理信息结构（SMI）。SMIv1目前被独立出来，不应当再被使用。如果你选择修改MIB的某些东西，你需要学习SMIv2和ASN.1语法，不过其他情况下你只需要在兴趣时看看他，而不必学习他。<br/></span>To this day, SNMPv1 and SNMPv2c are the most commonly used, however due to the insecurity inherent to these protocols read-only access is typical. In general, don’t bother with SNMPv3 unless you really need the added security features.<br/><span style="color: rgb(0, 0, 255);">现在，SNMPv1和SNMPv2被广泛应用，但是由于这些协议的不安全特性，通常只使用只读访问。通常，除非你确实需要附加安全特性，否则你不需要过多地关注SNMPv3。SNMPv3是具有安全性的通信协议。<br/></span>1.3. 本文不涉及的话题 <br/><span style="color: rgb(255, 0, 0);">本文中不会涉及如何编写代理、MIB模块等方面的话题。</span><br/>
There are several subject we will not be discussing in this paper. These topics include writing agents or sub-agents, writing MIB modules, trap generation and trap sending, synchronous vs asynchronous SNMP coding, and MIB parsing.<br/><span style="color: rgb(0, 0, 255);">本文中，有几个主题我们不会讨论。这些主题包括编写代理或子代理，编写MIB模块、陷阱生成以及陷阱发送、同步和一步SNMP代码编写，以及MIB解释器。<br/></span>Something that scares new or inexperienced coders away from the Net-SNMP documentation is the seemingly constant reference to synchronous and asynchronous applications. Don’t be afraid, thats referring to applications that can’t afford to sit and wait for a response. If your application needs a non-blocking method of handling SNMP traffic, use the asynchronous interface (eg: GUIs, Threads, Forking, etc). Otherwise, just stick with the synchronous interfaces for typical use.<br/><span style="color: rgb(0, 0, 255);">Net-SNMP中关于同步和异步应用程序的文档，常常会把没有经验的编码新手给吓唬住。别担心，那只是指无法坐等响应的应用程序。如果你的应用程序需要以非阻塞方式处理SNMP数据流，就使用一步接口（例如GUI、线程、forking等）。否则，只需要使用同步接口就可以了。</span><br/>
Lastly, this document addresses the use of Net-SNMP on UNIX systems only. Please refer to the Net-SNMP website for information regarding development on Win32.<br/>
本文中的后面会针对Unix系统中使用的问题，请参考Net-SNMP网站了解关于在Win32中开发的信息。<br/><br/>
2. MIB和OID <br/><span style="color: rgb(255, 0, 0);">OID(对象标识符），是SNMP代理提供的具有唯一标识的键值。MIB（管理信息基）提供数字化OID到可读文本的映射。<br/></span>2.1. OID <br/>
OID的编写规则和习惯<br/>
SNMP OIDs are laid out in a hierarchy forming unique addresses into a tree similar to the DNS hierarchy. Like many other forms of addressing, OIDs can be used in 2 forms: fully qualified and relative (sometimes called ”relevant”).<br/>
SNMP OID是用一种按照层次化格式组织的、树状结构中的唯一地址来表示的，它与DNS层次相似。与其他格式的寻址方式类型，OID以两种格式加以应用：全名和先对名（有时称为“相关”）<br/>
The fully qualified form starts from the root and moves outward to the individual value on a device. An example of a fully qualified address is:<br/>
完全验证格式从root根开始，并且向外移到某个设备的独立的质上。例如一个完整验证的地址为:<br/>
This OID could be rewritten in human readable form as:<br/>
该OID可用人们可读的方式重写为：<br/>
All fully qualified OIDs will begin with .iso.org.dod.internet.private represented numerically as .1.3.6.1.4. Almost all OIDs will then be followed by enterprises (.1) and a unique number for the vendor as assigned by the Internet Assigned Numbers Authority (IANA). In the example OID 789 represents the vendor ID for the Network Appliance Corporation (NetApp). Everything beyond the vendor ID is based on the vendors implementation and may vary between implementations. Please note the prefixing dot before iso. Similar to the trailing dot in DNS, properly qualified IODs begin with a dot representing the root.<br/>
所有完全验证OID都有 .iso.org.dod.internet.private 开始，数字表达为: .1.3.6.4. 。几乎所有的OID都会跟上企业(.1)和由IANA（互联网编号分配中心分配的）唯一的厂商标号。例如OID 789表示Network Appliance格式的厂商编号( NetApp ）。厂商编号后面的是基于厂商实现的功能，并且各不相同。请注意，在iso.前面的 . ` ，与DNS中的后点相似，正确验证的OID是有一个表示根的前缀 `. 开始的。<br/>
The complete list of enterprise assignments can be found at the IANA website: <a href="http://www.iana.org/assignments/enterprise-numbers" style="text-decoration: none; color: rgb(0, 0, 0);" target="_blank"><span style="color: rgb(170, 208, 208);"><u>http://www.iana.org/assignments/enterprise-numbers</u></span></a><br/>
IANA网站上找到企业分配完整的清单 : <a href="http://www.iana.org/assignmenets/enterprise-numbers" style="text-decoration: none; color: rgb(0, 0, 0);" target="_blank"><span style="color: rgb(170, 208, 208);"><u>http://www.iana.org/assignmenets/enterprise-numbers</u></span></a><br/>
The relative form of an OID, on the other hand, begins from the enterprises value and leaves all the implied addressing off. So we can use the relative form of the above OID as enterprises.netapp.netapp1.raid.diskSummary.diskSpareCount.0 or numerically as .1.789.1.6.4.8.0 .<br/><span style="color: rgb(0, 0, 255);">OID的相对格式，从企业值开始，略过所有的隐含地址。因此，我们可以用相对地址</span> enterprises.netapp.netappl.raid.diskSUmmary.diskSpaceCount.0 来表示上述的OID，或者用数字格式 .1.789.6.4.8.0 .<br/>
A common form of writing OIDs is by the name of the MIB and a unique key defined within the MIB. For instance, we could rewrite the above OID into the condensed form NETWORK-APPLIANCE-MIB::diskSpareCount.0 . This condensed form follows the convention of MIB Name::Unique Key.instance. Some keys, while unique, can be represented by multiple instances of that key, and thus all OIDs end with an instance value. This is why you’ll notice that most OIDs end with a .0 .<br/>
写OID的常用格式是用MIB名称和在MIB中定义的唯一键值。例如，我们可以用简写的格式重写上述OID: <br/><span style="color: rgb(255, 0, 255);">NETWORK-APPLIANCE-MIB::diskSpareCount.0</span> <br/><span style="color: rgb(0, 0, 255);">MIB中OID的书写格式规则为：:MIB Name::唯一键值.instance.</span><br/>
某些唯一键值，可用多个实例表示，这样所有的OID都以实例值结尾。这就是为什么你得注意到大多数OID都是以一个 .0 结尾的。<br/><br/>
2.2. MIB <br/>
MIB介绍<br/>
The structure of a MIBs internals are a little strange and foreign at first, but it’s structured well enough that you can poke through it pretty intelligently without really knowing what your doing. The structure of a MIB comes from the Structure of Management Information (SMI) standard detailed in IETF RFC 1155 and 2578. If you choose to modify or write your own MIBs you’ll benefit from understanding SMI before hacking much on MIBs.<br/><span style="color: rgb(0, 0, 255);">MIB的内部结构刚开始时会让人感觉有些奇怪和不好理解，不过它的结构非常好，你可以在不懂的情况下一个一个看进去。MIB的结构来源于IETF RFC1155和2578定义的管理信息结构。如果你想要修改或编写自己的MIB，在动手前理解SMI非常有帮助。</span><br/>
Lets look at the header of a MIB to get a better idea of how they work:<br/><span style="color: rgb(0, 0, 255);">为了更好地理解他们是怎样工作的，我们先来看看MIB的头:</span><br/>
-- PowerNet-MIB {iso org(3) dod(6) internet(1) private(4)<br/>
-- enterprises(1) apc(318) }<br/><br/>
PowerNet-MIB DEFINITIONS ::= BEGIN<br/><br/>
IMPORTS<br/>
enterprises, IpAddress, Gauge, TimeTicks FROM RFC1155-SMI<br/>
DisplayString FROM RFC1213-MIB<br/>
OBJECT-TYPE FROM RFC-1212<br/>
TRAP-TYPE FROM RFC-1215;<br/><br/>
apc OBJECT IDENTIFIER ::= { enterprises 318 }<br/>
products OBJECT IDENTIFIER ::= { apc 1 }<br/>
apcmgmt OBJECT IDENTIFIER ::= { apc 2 }<br/><br/>
Comments can be inserted into a MIB by prepending them with two dashes. In the header the declaration BEGIN starts off the MIB. Imports can be used to pull information from other MIBs, typically those mandated by the MIB-II standard.<br/><span style="color: rgb(0, 0, 255);">可以用<span style="color: rgb(255, 0, 255);">行开头为 --</span> 的方法在MIB中<span style="color: rgb(255, 0, 255);">加入注释</span>。</span><br/><span style="color: rgb(0, 0, 255);">在<span style="color: rgb(255, 0, 255);">头部用 BEGIN`声明来开始MIB的定义</span>。 </span><br/><span style="color: rgb(0, 0, 255);">`Imports 可用来<span style="color: rgb(255, 0, 255);">从其他MIB中提取信息,通常用它来提取MIB-II规范要求的内容</span>。</span><br/>
The MIB lays out the structure of OID addresses starting from the enterprises value. Here the enterprise value 318 maps to ”apc” (relative address .1.318). Typically then several categories are defined. Here we see 2 categories: products (.1.318.1) and apcmgmt (.1.318.2). Notice that in the curly braces two values are specified, its parent address followed by its address. So the products identifier is parented by the apc identifier which is parented by the enterprises identifier, so on and so forth. This type of categorization and subcategorizing will typically continue on in the header of the MIB for awhile segmenting the available keys into tight subgroupings. By segmenting values out in this way it makes the available keys easier to navigate.<br/><span style="color: rgb(0, 0, 255);">MIB放置从enterprise值开始的OID地址的结构。在此，enterprise值是318, 对应 &quot;apc&quot; (相对地址为 .1.318）。 通常之后会定义几个类别。注意在花括号间定义的两个值,其父地址后面跟一个它自己的地址。因此产品标识符有apc标识符表示，其父为enterprise标识符，以此类推。类别和自类别的类型通常跟在MIB头的后面，并且把有用的键值分割为子组。通过分段，各种值分别被列出，这样可用的值更容易浏览。</span><br/>
The real meat of the MIB is in the description of object types. Here’s an example of a integer key:<br/><span style="color: rgb(0, 0, 255);">MIB的真正好处在于对象类型的描述。以下是一个整形键值的例子:</span></font><div><div><ol><li><font size="3">upsBasicOutputStatus OBJECT-TYPE</font></li><li><font size="3">SYNTAX INTEGER {</font></li><li><font size="3">   unknown(1),</font></li><li><font size="3">   onLine(2),</font></li><li><font size="3">   onBattery(3),</font></li><li><font size="3">   onSmartBoost(4),</font></li><li><font size="3">   timedSleeping(5),</font></li><li><font size="3">   softwareBypass(6),</font></li><li><font size="3">   off(7),</font></li><li><font size="3">   rebooting(8),</font></li><li><font size="3">   switchedBypass(9),</font></li><li><font size="3">   hardwareFailureBypass(10),</font></li><li><font size="3">   sleepingUntilPowerReturn(11),</font></li><li><font size="3">   onSmartTrim(12)</font></li><li><font size="3">}</font></li><li><font size="3">ACCESS read-only</font></li><li><font size="3">STATUS mandatory</font></li><li><font size="3">DESCRIPTION</font></li><li><font size="3">   &quot;The current state of the UPS. If the UPS is unable</font></li><li><font size="3">    to determine the state of the UPS this variable is set</font></li><li><font size="3">    to unknown(1).&quot;</font></li><li><font size="3">::= { upsBasicOutput 1 }</font></li></ol></div><span style="color: rgb(51, 102, 153);"><font size="3">复制代码</font></span></div><font size="3">Here is defined the upsBasicOutputStatus key with a return type of INTEGER. The returned integer maps to one of 12 different return values as listed. Notice that in the MIB a description of the key is provided. These descriptions can be extremely useful in determining which objects can best provide the data you want, especially if you don’t have MIB documentation supplied by the vendor.<br/><span style="color: rgb(0, 0, 255);">在此定义了一个具有整型返回值的upsBasicOutputStatus键值。返回的整型对应到列出的12个不同的数值中的一个。注意在MIB中，提供了该键值的描述。在确定那个对象能够提供最好地你需要的数据时，特别有帮助，特别是当厂商没有提供MIB文档的情况下。</span><br/>
Notice also that the last line of the object type description includes the numeric value 1 with upsBasicOutput as the parent. If we follow this parenting backwards in the MIB we’d find that upsBasicOutput has the value 1 and is parented by upsOutput which has the value 4 and is parented by ups which has a value of 1, which is parented by hardware which has a value of 1, which is parented by products with a value of 1 which is parented by apc with a value of 318, which is parented by enterprises with a value of 1. So, if we put all that mapping together we get a relative address for the key upsBasicOutputStatus of .1.318.1.1.1.4.1.1.0. Remember that the trailing .0 represents the first instance of the key. Applications called MIB Browsers can easily parse a MIB and make navigation much quicker than flipping through the file in vim, but don’t be fooled into thinking it’s difficult without such a tool.<br/><span style="color: rgb(0, 0, 255);">注意对象类型描述的最后一行包括有数值1，其父为数字为1的upsBasicOutput。如果我们按照这个父节点返推，我们会发现upsBasicOutput的值为1，并且其父节点是值为4的upsOutput, upsOutput的父节点是值为1的ups，upsOutput的父节点是值为1的hardware, hardware的父节点是值为1的products，products的父节点是值为318的apc,apc的父节点的是值为1的enterprise。因此，如果我们我们把所有的对应关系合起来，我们就得到 .1.319.1.1.1.4.1.1.0的upsBasicOutputStatus键值的相对地址。记住末尾的.0表示该键值的第一个实例。MIB浏览器这样的应用程序可以简化MIB解析，它能够比通过vim浏览文件的方式更加快捷地浏览，不过不要以为没有这样的工具就非常困难了。<br/></span>So, whats really important to notice here is that the MIB is really just providing us with a road map of the OIDs available on the agent we wish to get values from. A MIB describes both where to find a value and what it returns. We can still interface with a device without the MIB, it’s just much easier when you get a return of ”Up” instead of ”1”. By leveraging the options of the Net- SNMP CLI tools you can decide just how you wish to return output which will be different if your just using the tool from the command line (where ”Up” is preferable) or if your calling the tool from a script (where ”1” is preferable).<br/><span style="color: rgb(0, 0, 255);">因此，在这里真正需要注意的是，MIB其实只是提供给我们一张我们想从某个SNMP代理中获得的可用OID的各种值的地图。一个MIB描述了在哪里找某个值、以及返回结果是什么。我们可以不用MIB与设备进行交互，只不过在理获得'Up'的返回值，要比‘1’的返回值要简单的多。通过利用Net-SNMP命令行工具，你可以决定你希望返回结果的输出样式（这种方式下使用“Up&quot;这样的格式更好），或者你用脚本调用工具时（这种方式下使用”1“的格式就更好）。</span><br/><span style="color: rgb(0, 0, 255);"><br/></span>2.3. OID数据类型 <br/><span style="color: rgb(255, 0, 255);">SMI定义的OID返回值的数据类型。</span><br/>
SMI defines a fixed number of datatypes which are returned by OIDs. These datatypes include:<br/><span style="color: rgb(0, 0, 255);">SMI定义了一定数量的OID返回的数据类型。这些数据类型包括：</span><br/><span style="color: rgb(255, 0, 0);">Integer</span> 整型<br/>
Signed 32bit Integer (values between -2147483648 and 2147483647). 有符号32位整数（值范围: -2147483648 - +2147483648） <br/><span style="color: rgb(255, 0, 0);">Integer32</span> <br/>
Same as Integer. 与Integer相同。 <br/><span style="color: rgb(255, 0, 0);">UInteger32</span> <br/>
Unsigned 32bit Integer (values between 0 and 4294967295). 无符号32位整数（值范围：0－4294967295）. <br/><span style="color: rgb(255, 0, 0);">Octet String</span> <br/>
Arbitrary binary or textual data, typically limited to 255 characters in length. 任意二进制或文本数据，通常长度限制在255个字符内。 <br/><span style="color: rgb(255, 0, 0);">Object Identifier</span> <br/>
An OID. 一个OID。 <br/><span style="color: rgb(255, 0, 0);">Bit String</span> <br/>
Represents an enumeration of named bits. This is an unsigned datatype. 表示取名的位的枚举。这是一个无符号的数据类型。 <br/><span style="color: rgb(255, 0, 0);">IpAddress</span> <br/>
An IP address. 一个IP地址。 <br/><span style="color: rgb(255, 0, 0);">Counter32</span> <br/>
Represents a non-negative integer which monotonically increases until it reaches a maximum value of 32bits-1 (4294967295 dec), when it wraps around and starts increasing again from zero. 表示一个非负的整数（可递增到32位最大值－1），然后恢复并从0开始递增。 <br/><span style="color: rgb(255, 0, 0);">Counter64</span> <br/>
Same as Counter32 but has a maximum value of 64bits-1. 与Counter32相同，最大值为64位的最大值－1。 <br/><span style="color: rgb(255, 0, 0);">Gauge32</span> <br/>
Represents an unsigned integer, which may increase or decrease, but shall never exceed a maximum value. 表示无符号整数，可增加或减少，但是不超过最大值。 <br/><span style="color: rgb(255, 0, 0);">TimeTicks <br/></span>Represents an unsigned integer which represents the time, modulo 2ˆ32 (4294967296 dec), in hundredths of a second between two epochs. 表示代表数据的一个无符号整数，2^32取模（4294967296），两个值之间为百分之一秒。 <br/><span style="color: rgb(255, 0, 0);">Opaque <br/></span>Provided solely for backward-compatibility, its no longer used. 提供向下兼容，不再使用的数据类型 <br/><span style="color: rgb(255, 0, 0);">NsapAddress <br/></span>Represents an OSI address as a variable-length OCTET STRING. 表示一个用变长八进制字符窗表示的OSI地址。 <br/><br/>
Net-SNMP tools will report the datatype when returning an OID unless you otherwise disregard it. As an example of that you’ll see:<br/>
Net-SNMP工具在返回一个OID时会包括其数据类型，除非你不想要他。以下是一个例子：<br/>
SNMPv2-MIB::sysContact.0 = STRING: Ben Rockwood<br/>
IF-MIB::ifPhysAddress.1 = STRING: 0:c0:b7:63:ca:4c<br/>
SNMPv2-MIB::sysUpTime.0 = Timeticks: (47372422) 5 days, 11:35:24.22<br/>
IF-MIB::ifAdminStatus.1 = INTEGER: up(1)<br/>
SNMPv2-MIB::sysObjectID.0 = OID: SNMPv2-SMI::enterprises.318.1.3.7<br/>
RFC1213-MIB::atPhysAddress.1.1.10.10.1.1 = Hex-STRING: 00 50 73 28 47 A0<br/>
RFC1213-MIB::atNetAddress.1.1.10.10.1.1 = Network Address: 0A:0A:01:01<br/>
IF-MIB::ifSpeed.1 = Gauge32: 10000000<br/>
SNMPv2-MIB::snmpInPkts.0 = Counter32: 316<br/>
SNMPv2-MIB::snmpOutPkts.0 = Counter32: 314<br/><br/>
This is a fairly typical spread of datatypes returned by Net-SNMP tools. Notice that some values are being automatically interpreted by Net-SNMP, such as the sysUpTime and ifAdminStatus. The MIB was used when these values were returned and Net-SNMP was nice enough to find the return value in the MIB and give us the textual representation of the value.<br/>
这是一个相当典型的由Net-SNMP工具返回的数据类型表单。注意有些值已经由Net-SNMP自动解释了，比如sysUpTime和ifAdminStatus。这些值返回时使用到MIB，Net-SNMP会在MIBzhong找到返回值，并且为我们提供该值的文本表示。<br/><br/>
2.4. MIB II <br/>
MIB II<br/>
IETF RFC 1213 ”defines the second version of the Management Information Base (MIB-II) for use with network management protocols in TCP/IP-based internets.” All SNMP agent and tool distributions should include MIBs that will comply with MIB-II and all devices should at the very least return values that comply with the MIB-II standard.<br/>
Within the MIB-II standard several OID groups are defined, including:<br/>
The System Group <br/>
Basic system identification and information OIDs such as sysDescr, sysContact, sysName, SysLocation, etc. (Reported by Net-SNMP in SNMPv2-MIB) <br/>
The Interfaces Group <br/>
Network Interface information such as ifDescr, ifType,ifSpeed, ifAdminStatus, etc. (Reported by Net-SNMP in IF-MIB) <br/>
The Address Translation Group <br/>
Address Translation (AT) information mapping Physical to Logical addressing such as atNetAddress, atPhysAddress,etc. (Reported by Net-SNMP in RFC1213-MIB) <br/>
The IP Group <br/>
IP stats and settings such as ipInReceives, ipForwarding, ip-InAddrErrors, etc. (Reported by Net-SNMP in IP-MIB) <br/>
The ICMP Group <br/>
ICMP stats and settings such as icmpInMsgs, icmpIn-Errors, icmpInRedirects, etc. (Reported by Net-SNMP in IP-MIB) <br/>
The TCP Group <br/>
TCP stats and settings such as tcpActiveOpens, tcpPassiveOpens,tcpInErrs, etc. (Reported by Net-SNMP in TCP-MIB) <br/>
The UDP Group <br/>
UDP stats and settings such as udpInDatagrams, udpIn-Errors, etc. (Reported by Net-SNMP in UDP-MIB) <br/>
The EGP Group <br/>
EGP stats and settings (if the device support EGP) such as egpNeighAs, egpNeighMode, etc (Reported by Net-SNMP in RFC1213-MIB) <br/>
The Transmission Group <br/>
Device specific media transmition stats and settings(Reported by Net-SNMP in RFC1213-MIB or your vendor MIB) <br/>
The SNMP Group <br/>
SNMP stats and settings such as snmpInPkts, snmp-InASNParseErrs, snmpInTraps, etc. (Reported by Net-SNMP in SNMPv2-MIB) <br/>
If you do a default walk of an SNMP device the MIB-II data should be returned. All data with the exception of the EGP and Transmission groups are requirements of the standard. For most networking devices such as routers this information is usually sufficient to provide most of the information you could want.<br/>
2.5. 为Net-SNMP添加MIB <br/>
如何为Net－SNMP添加MIB信息<br/>
Additional MIBs can be added to your Net-SNMP installation by simply copying them into the $(PREFIX)/share/snmp/mibs directory. MIBs should be (re)named to follow the convention (MIB NAME).txt for clarity. You can find the MIBs proper name on the first uncommented line of the MIB (eg: Name- MIB DEFINITIONS ::= BEGIN).<br/>
For example, if you downloaded MIB for the JetDirect Management Card found on HP LaserJet printers it might have been named something like ”hpjetdirect. mib”. The header of the MIB looks like the following:<br/>
-- (C) COPYRIGHT HEWLETT-PACKARD COMPANY 1997.<br/>
-- LaserJet 5Si Printer Model Specific MIB.<br/>
--<br/>
LaserJet5Si-MIB DEFINITIONS ::= BEGIN<br/><br/>
This MIB should be renamed to ”LaserJet5Si-MIB.txt” and copied into the Net-SNMP mibs/ directory.<br/>
By following this convention it assures greater clarity when utilizing the various MIBs and a consistency with all other installed MIBs.<br/>
MIBs can be specified by a command line tool using the -m argument or the MIBS environmental variable for libsnmp applications including the PERL module. MIBs can be referenced locally by supplying a proper path (ie: - m ”./MY MIB.txt”) or globally by supplying the MIB name without the .txt suffix (ie: -m ”MY MIB”) if it’s located in the Net-SNMP MIBs directory.</font></td></tr></tbody></table></span>
</div></body></html> 