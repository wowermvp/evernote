<html>
<head>
  <title>Linux服务管理</title>
  <basefont face="宋体" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/600718 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 宋体;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1829"/>
<h1>Linux服务管理</h1>

<div>
<span style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;"><div>一、服务的简介与分类</div><div>1、服务的分类</div><div>          <img src="Linux服务管理_files/Image.png" type="image/png" data-filename="Image.png" style="cursor: default;cursor: default;"/></div><div>     RPM包默认安装的服务</div><div>这些服务是通过RPM包安装的，可以被服务管理命令识别。又分为两种子分类：</div><div>     独立的服务：就是独立启动的意思，这类型的服务可以自行启动，而不用这依赖其他的管理服务。不依赖其他的管理服务，那么当客户端请求访问时，独立的服务响应请求更快速。Linux中目前大多数服务都是独立服务，比如apache服务，FTP服务，Samba服务等。</div><div>     基于xinetd的服务：这种服务就不能独立启动了，而是依靠管理服务来调用这种服务。这个负责管理的服务就是xinetd服务，xinetd服务是系统的超级守护进程。xinetd服务作用就是管理不能独立启动的服务，当有客户端请求时，先请求xinetd服务，由xinetd服务去唤醒相对应的服务。当客户端请求结束后，被唤醒的服务会关闭并释放资源。这样做的好处是只需要持续启动xinetd服务，而其他基于xinetd的服务只有在需要时才启动。不会占用过多的服务器资源。但是这种服务由于在客户端请求时才会被唤醒，所以响应时间相对较慢。</div><div>     源码包安装的服务</div><div>2、查询已经安装的服务和区分服务</div><div>[root@localhost ~]# chkconfig --list [服务名]</div><div>选项：</div><div>     --list：列出所有RPM默认安装服务的自启动状态</div><div>二、RPM包默认安装的服务管理</div><div>1、独立服务管理</div><div>     1）独立服务的启动管理</div><div>使用/etc/init.d/目录中的启动脚本启动服务</div><div>[root@localhost ~]# /etc/init.d/httpd start</div><div>使用service命令来启动独立的服务</div><div>[root@localhost ~]# service     独立服务名 start|stop|restart|...</div><div>2）独立服务的自启动管理</div><div>     使用chkconfig服务自启动管理命令</div><div>[root@localhost ~]# chkconfig [--level 运行级别] [独立服务名] [on|off]</div><div>选项：</div><div>     --level：设定在哪个运行级别中开机自启动（on），或是关闭自启动（off）。</div><div>     修改/etc/rc.d/rc.local文件，设置服务自启动</div><div>[root@localhost ~]# vi /etc/rc.d/rc.local<br/>
#!/bin/sh<br/>
#<br/>
# This script will be executed *after* all the other init scripts.<br/>
# You can put your own initialization stuff in here if you don't<br/>
# want to do the full Sys V style init stuff.<br/><br/>
touch /var/lock/subsys/local</div><div><br/></div><div>     使用ntsysv命令管理自启动</div><div>[root@localhost ~]# ntsysv [--level 运行级别]</div><div>选项：</div><div>     --level 运行级别：可以指定设定自启动的运行级别</div><div>     这个命令的操作是这样的：</div><div>          上下键：在不同的服务之间移动</div><div>          空格键：选定或取消移动服务的自启动。就是在服务之前是否打入“*”</div><div>          tab键：  在不同的项目间切换</div><div>          F1键：   显示服务的说明</div><div>2、基于xinetd服务的管理</div><div>     1）基于xinetd服务的启动</div><div>     以telnet服务为例，telnet服务是用来进行系统远程管理的，端口是23。注意telnet的远程管理数据在网络中是明传输的，非常不安全。所以在生产服务器上是不建议启动telnet的。在生产服务器上，远程管理使用的转文是ssh协议，ssh是加密的更加安全。</div><div>[root@localhost ~]# vi /etc/xinetd.d/telnet</div><div>#defalut:on</div><div>#descrption:The telnet server telnet sessions; it uses \</div><div>#     unencrypted username/password pairs for authentication.</div><div>service telnet                                                   #服务名称为telnet</div><div>{</div><div>     flags                = REUSE                              #标志为REUSE，设定TCP/IP socket可重用</div><div>     socket_type     = stream                             #使用TCP协议数据包</div><div>     wait                 = no                                    #允许多个连接同时连接</div><div>     user                 = root                                 #启动服务的用户为root</div><div>     server              = /usr/sbin/in.telnetd          #服务启动程序</div><div>     log_on_failure  += USERID                         #登陆失败后，记录用户的ID</div><div>     disable             = yes                                  #服务不启动</div><div>}</div><div>[root@localhost ~]# vi /etc/xinetd.d/telnet</div><div>service telnet</div><div>{</div><div>...省略部分输出...</div><div>     disable               = no                                  #将yes改为no</div><div>}</div><div>[root@localhost ~]# service xinetd restart</div><div>     2）基于xinetd服务的启动</div><div>     使用chkconfig命令管理自启动</div><div>     使用ntsysv命令管理自启动</div><div>[root@localhost ~]# chkconfig 服务名 on|off</div><div>#基于xinetd的服务，没有自己的运行级别，是依靠xinetd服务的运行级别。所以不用指定--leverl选项</div><div>3、独立服务启动脚本分析</div><div>[root@localhost ~]# vi /etc/init.d/httpd</div><div>#!/bin/bash</div><div>#</div><div>#httpd          Starup script for the Apache HTTP Server</div><div>#</div><div>#chkconfig:  -85 15</div><div>#自启动设定  -代表自启动级别，85（S85）代表启动序号，15（K15）代表关闭序号。</div><div>#dscription:     The Apache HTTP Server is an efficient and extensible \</div><div>#                     server implementing the current HTTP standards.</div><div>#服务描述。以上两行用于apache自启动。</div><div>#processname: httpd</div><div>#config: /etc/httpd/conf/httpd.conf</div><div>#config: /etc/sysconfig/httpd</div><div>#pidfile: /var/run/httpd/httpd.pid</div><div>#</div><div>###BEGIN INIT INFO</div><div>#Provides: httpd</div><div>#Required-Start: $local_fs $remote_fs $network $named</div><div>#Required-Stop: $local_fs #remote_fs $network</div><div>#Should-Start: discache</div><div>#Short-Description: start and stop Apache HTTP Server</div><div>#Description: The Apache HTTP Server is an extensible server</div><div>#     implementing the current HTTP standards.</div><div>###END INIT INFO</div><div>#以上为注释</div><div><br/></div><div>#Source function libary.</div><div>. /etc/rc.d/init.d/functions</div><div>#“.”其实就是source，就是调用functions文件</div><div><br/></div><div>if [ -f /etc/sysconfig/httpd ];then</div><div>     . /etc/sysconfig/httpd</div><div>fi</div><div>#判断httpd如果是文件，则调用httpd文件</div><div><br/></div><div>#Start httpd in the C locale by fault</div><div>HTTPD_LANG=${HTTPD_LANG-&quot;C&quot;}</div><div>#定义变量HTTPD_LANG的值。并追加变量的值为C，即英文</div><div><br/></div><div>#This will prevent initlog from swallowing up a pass-phrase prompt if</div><div>#mod_ssl needs a pass-phrase from the user.</div><div>INITLOG_ARGS=&quot;&quot;</div><div><br/></div><div>#Set HTTPD=/usr/sbin/httpd. worker in /etc/sysconfig/httpd to use a server</div><div>#with the thread-based &quot;worker&quot; MPM; BE WARNED that some modules may not</div><div>#work correctly with a thread-based MPM; notably PHP will refuse to start.</div><div><br/></div><div>#Path to the apachectl script, server binary, and short-form for messages.</div><div>apachectl=/usr/sbin/apachectl</div><div>http=${HTTPD-/usr/sbin/httpd}</div><div>prog=httpd</div><div>pidfile=${PIDFILE-/var/run/httpd/httpd.pid}</div><div>lockfile=${LOCKFILE-/var/lock/subsys/httpd}</div><div>#定义一系列变量，用于后面的执行</div><div>RETVAL=0</div><div>#定义全局命令返回变量</div><div>STOP_TIMEOUT=${STOP_TIMEOUT-10}</div><div><br/></div><div>#The semantics of these two functions differ from the way apachectl does</div><div>#things -- attempting to start  while running is a failure, and shutdown</div><div>#when not running is also a failure. So we just do it the way init scripts</div><div>#are expected to behave here.</div><div>start() {</div><div>     echo -n $&quot;Starting $prog:&quot;</div><div>     LANG=$HTTPD_LANG daemon --pidfile=${pidfile} $httpd $OPTIONS</div><div>     RETVAL=$?</div><div>     echo</div><div>     [  $RETVAL = 0 ] &amp;&amp; touch ${lockfile}</div><div>     return $RETVAL</div><div>}</div><div>#定义start函数，用于apache的启动</div><div>#如果守护进程/usr/sbin/httpd启动成功（$RETVAL = 0），就建立/var/lock/subsys/httpd文件</div><div>#(touch ${lockfile})。通过$httpd变量执行/usr/sbin/httpd命令启动apache。</div><div>#通过$pidfile变量调用apache的PID。通过变量$OPTIONS定义命令执行时的初始化环境配置</div><div>#依赖/etc/sysconfig/httpd文件</div><div><br/></div><div>#When stopping httpd, a delay (of default 10 second) is required</div><div>#before SIGKILLing the httpd parent; this gives enough time for the</div><div>#httpd parent to SIGKILL any errant chilren.</div><div>stop(){</div><div>     echo -n $&quot;Stopping $prog:&quot;</div><div>     killproc -p ${pidfile} -d ${STOP_TIMEOUT} $httpd</div><div>     REVAL=$?</div><div>     echo</div><div>     [ $REVAL=0 ] &amp;&amp; ${lockfile} ${pidfile}</div><div>}</div><div>#定义stop函数，用来关闭apache服务，关闭服务之后会删除pid文件</div><div>reload() {</div><div>     ehco -n $&quot;Reloading $prog:&quot;</div><div>     if ! LANG=$HTTPD_LANG $httpd $OPTIONS -t &gt;&amp;/dev/null;then</div><div>          REVAL=6</div><div>          echo $&quot;not reloading due to configuration syntax error&quot;</div><div>          failure $&quot;not reloading $httpd due to configuration syntax error&quot;</div><div>     else</div><div>          #Force LSB behaviour from killproc</div><div>          LSB=1 killproc -p ${pidfile} $httpd -HUP</div><div>          RETVAL=$?</div><div>          if [ $RETVAL -ea 7 ];then</div><div>               failure $&quot;httpd shutdown&quot;</div><div>          fi</div><div>     fi</div><div>     echo</div><div>}</div><div>#定义reload函数，用于apache的重新加载</div><div>#通过/usr/sbin/httpd -t命令判断apache的配置文件。如果配置文件报错，则输出错误提示。如果配置正确，则重新加载apache。</div><div><br/></div><div>#see how we were called</div><div>case &quot;$1&quot; in</div><div>#判断执行脚本后的第一个参数的值，$1表示执行脚本时的第一个参数</div><div>     start)</div><div>          start</div><div>          ;;</div><div>          ;;</div><div>#如果参数值为start，则调用start函数</div><div>     stop)</div><div>          stop</div><div>          ;;</div><div>#如果参数值为stop，则调用stop函数</div><div>     status)</div><div>          status -p ${pidfile} $httpd</div><div>          RETVAL=$?</div><div>          ;;</div><div>#如果参数值为status，则执行status -p $httpd命令测试apache状态</div><div>     restart)</div><div>          stop</div><div>          start</div><div>          ;;</div><div>#如果参数值为restart，则先调用stop函数，再调用start函数</div><div>     condrestart|try-restart)</div><div>          if status -p ${pidfile} $httpd &gt;&amp;/dev/null;then</div><div>               stop</div><div>               start</div><div>          fi</div><div>          ;;</div><div>#如果参数值为condrestart或try-restart，则只有apache服务是已经运行时才先调用stop函数，再调用start函数，重启apache。如果apache服务没有运行，则不重启apache。</div><div>     force-reload|reload)</div><div>          reload</div><div>          ;;</div><div>#如果参数值为force-reload或reload,则调用reload函数。</div><div>     graceful|help|configtest|fullstatus)</div><div>          $apachectl $@</div><div>          RETVAL=$?</div><div>          ;;</div><div>#如果参数是graceful或help或configtest或fullstatus，则执行/usr/sbin/apachectl命令，并把参数作为命令的参数传入apachectl命令。</div><div>     *)</div><div>          echo $&quot;Usage: $prog{start|stop|restart|condrestart|try-restart|force-reload|status|fullstatus|graceful|help|configtest}&quot;</div><div>     RETVAL=2</div><div>#如果输出的参数不是以上任何参数，则输出错误信息</div><div>esac</div><div>exit $RETVAL</div><div>     </div><div>三、源码包安装的服务管理</div><div>1、源码包服务的启动管理</div><div>[root@localhost ~]# /usr/local/apache2/bin/apachectl start|stop|restart|...</div><div>#源码包服务启动管理</div><div>2、源码包服务的自启动管理</div><div>[root@localhost ~]# vi /etc/rc.d/rc.local</div><div>#修改自启动文件</div><div>#!/bin/sh<br/>
#<br/>
# This script will be executed *after* all the other init scripts.<br/>
# You can put your own initialization stuff in here if you don't<br/>
# want to do the full Sys V style init stuff.<br/><br/>
touch /var/lock/subsys/local</div><div><font color="#E30000">/usr/local/apache2/bin/apachectl start</font></div><div>3、让源码包服务被服务管理命令识别</div><div>     如何让源码包安装的apache变为和RPM包安装的apache一样，可以被service、chkconfig、ntsysv命令识别。试验如下：</div><div>1）安装源码包的apache服务，并启动</div><div>#安装源码包的apache服务</div><div>[root@localhost ~]# /usr/local/apache2/bin/apachectl start</div><div>[root@localhost ~]# netstat -nltu | grep 80</div><div>tcp        0      0 :::80                       :::*                        LISTEN</div><div>#启动源码包的apache，查看端口确定已经启动</div><div>2）让源码包的apache服务能被service命令管理启动</div><div>[root@localhost ~]# ln -s /usr/local/apache2/bin/apachectl /etc/init.d/apache</div><div>#service命令其实只是在/etc/init.d/目录中查找是否有服务的启动脚本，所以只需做个软链接把源码包的启动脚本链接到/etc/init.d/目录中，就能被service命令管理了。</div><div>[root@localhost ~]# service apache restart</div><div>#虽然是源码包安装的apache，但是service命令也能生效</div><div>4）让源码包的apache服务能被chkconfig命令管理自启动</div><div>[root@localhost ~]# vi /etc/init.d/apache</div><div>#修改源码包apache的启动脚本（注意此文件是软链接，所以修改的还是源码包的启动脚本）</div><div>#!/bin/bash</div><div>#</div><div>#chkconfig:     35 86 76</div><div>#指定httpd脚本可以被chkconfig命令管理</div><div>#格式是：chkconfig:     运行级别 启动顺序 关闭顺序</div><div>#这里是让apache在3和5级别能被chkconfig命令管理，启动顺序是S86，关闭顺序是K76</div><div>#（自定义顺序不要和系统中已有的启动顺序冲突）</div><div>#description:     source package apache</div><div>#说明，内容随意</div><div>#以上两句话必须加入，才能被chkconfig命令识别</div><div>...省略部分输出...</div><div><br/></div><div>[root@localhost ~]# chkconfig --add apache</div><div>#让chkconfig命令能够管理源码包安装的apache</div><div>[root@localhost ~]# chkconfig --list |  grep apache</div><div>apache           0:关闭     1:关闭     2:关闭     3:启用     4:关闭     5:启用     6:关闭</div><div>#源码包安装的apache服务，能够被chkconfig命令管理</div><div>5）让ntsysv命令可以管理源码包apache</div><div>#ntsysv命令其实和chkconfig命令使用同样的管理机制，也就是说ntsysv已经可以进行源码包apache的自启动管理了。</div><div>总结：如果想让源码包服务被service命令识别并管理，只要做个软链接把启动脚本链接到/etc/init.d/目录中即可。要想让源码包服务被chkconfig命令识别，除了需要把服务启动脚本链接到/etc/init.d/目录中，还要修改这个启动脚本，在启动脚本的开头加入：</div><div>#chkconfig:     运行级别 启动顺序 关闭</div><div>#description:     说明</div><div>     然后需要使用“chkconfig --add 服务名”的方式把服务加入chkconfig命令管理中</div><div>命令格式如下：</div><div>[root@localhost ~]# chkconfig [选项] [服务名]</div><div>选项：</div><div>     --add:     把服务加入chkconfig命令管理</div><div>     --del:      把服务从chkconfig命令的管理中删除</div><div>例：</div><div>[root@localhost ~]# chkconfig --del httpd</div><div>#把apache服务从chkconfig命令的管理中删除</div><div>四、总结服务管理</div><div> <img src="Linux服务管理_files/Image [1].png" type="image/png" data-filename="Image.png" height="657" style="cursor: default;" width="781"/></div><div>五、Linux中常见服务的作用</div><div><table border="1" cellpadding="2" cellspacing="0" width="100%"><tbody><tr><td style="text-align: center;" valign="top">服务名称</td><td style="text-align: center;" valign="top">功 能 简 介</td><td style="text-align: center;" valign="top">建议</td></tr><tr><td valign="top">acpid</td><td valign="top">电源管理接口。如果是笔记本用户建议开启，可以监听内核层的相关电源事件。</td><td valign="top">开启</td></tr><tr><td valign="top">anacron</td><td valign="top">系统的定时任务程序。cron的一个子系统，如果定时任务错过了执行，可以通过anacron继续唤醒执行。</td><td valign="top">关闭</td></tr><tr><td valign="top">alsasound</td><td valign="top">Alsa声卡驱动。如果使用alsa声卡，开启</td><td valign="top">关闭</td></tr><tr><td valign="top">apmd</td><td valign="top">电源管理模块。如果支持acpid，就不需要apmd，可以关闭</td><td valign="top">关闭 </td></tr><tr><td valign="top">atd</td><td valign="top">指定系统在特定时间执行某个任务，只能执行一次。如果需要则开启，但我们一般使用crond来进行循环定时任务。</td><td valign="top">关闭</td></tr><tr><td valign="top">auditd</td><td valign="top">审核子系统。如果开启了此服务，SELinux的审核信息写入/var/log/audit/audit.log文件，如果不开启，审核信息会记录在syslog中</td><td valign="top">开启</td></tr><tr><td valign="top">autofs</td><td valign="top">让服务器可以自动挂载网络中的其他服务器的共享数据，一般用来自动挂载NFS服务。如果没有NFS服务建议关闭。</td><td valign="top">关闭</td></tr><tr><td valign="top">avahi-daemon</td><td valign="top">Avahi是zeroconf协议的实现。它可以在没有DNS服务的局域网里发现基于zeroconf协议的设备和服务。除非有兼容设备或使用zeroconf协议，否则关闭。</td><td valign="top">关闭</td></tr><tr><td valign="top">bluetooth</td><td valign="top">蓝牙设备支持。一般不会在服务器上启用蓝牙设备，关闭它</td><td valign="top">关闭</td></tr><tr><td valign="top">capi</td><td valign="top">仅对使用ISND设备的用户有用<br/></td><td valign="top">关闭</td></tr><tr><td valign="top">chargen-dgram</td><td valign="top">使用UDP协议的chargen server。主要功能是提供类似远程打字功能。</td><td valign="top">关闭</td></tr><tr><td valign="top">chargen-stream</td><td valign="top">同上。</td><td valign="top">关闭</td></tr><tr><td valign="top">cpuspeed</td><td valign="top">可以用来调整CPU的速率。当闲置时可以自动降低CPU频率来节省电量。</td><td valign="top">开启</td></tr><tr><td valign="top">crond</td><td valign="top">系统的定时任务，一般的Linux服务器都需要定时任务帮助系统维护。建议开启。</td><td valign="top">开启</td></tr><tr><td valign="top">cvs</td><td valign="top">一个版本控制系统</td><td valign="top">关闭</td></tr><tr><td valign="top">daytime-dgram</td><td valign="top">daytime使用TCP协议的Daytime守护进程，该协议为客户机实现从远程服务器获取日期和时间功能。</td><td valign="top">关闭</td></tr><tr><td valign="top">daytime-stream</td><td valign="top">同上</td><td valign="top">关闭</td></tr><tr><td valign="top">dovecot</td><td valign="top">邮件服务中POP3/IAMP服务的守护进程。主要用来接收信件，如果启动了邮件服务则开启，否则关闭</td><td valign="top">关闭</td></tr><tr><td valign="top">echo-dgram</td><td valign="top">服务器回显客户服务的进程。</td><td valign="top">关闭</td></tr><tr><td valign="top">echo-stream</td><td valign="top">同上</td><td valign="top">关闭</td></tr><tr><td valign="top">firstboot</td><td valign="top">系统安装完后，有个欢迎界面，需要对进程初始设定。就是这个进程的作用。既然不是第一次启动，关闭它</td><td valign="top">关闭</td></tr><tr><td valign="top">gpm</td><td valign="top">在字符终端（tty1-tty6） 中可以使用鼠标复制和粘贴。就是这个服务的功能。</td><td valign="top">开启</td></tr><tr><td valign="top">haldaemon</td><td valign="top">检测和支持USB设备。如果是服务器可以关闭，个人机建议开启</td><td valign="top">关闭</td></tr><tr><td valign="top">hidd</td><td valign="top">蓝牙鼠标、键盘等蓝牙设备检测。必须启动bluetooth服务。</td><td valign="top">关闭</td></tr><tr><td valign="top">hplip</td><td valign="top">HP打印机支持，如果没有HP打印机关闭。</td><td valign="top">关闭</td></tr><tr><td valign="top">httpd</td><td valign="top">apache服务的守护进程。如果需要启动apache，就开启。</td><td valign="top">开启</td></tr><tr><td valign="top">ip6tables</td><td valign="top">IPv6的防火墙，目前IPv6协议没有使用，可以关闭</td><td valign="top">关闭</td></tr><tr><td valign="top">iptables</td><td valign="top">防火墙功能，Linux中防火墙是内核支持功能。这是服务器的主要防护手段，必须开启</td><td valign="top">开启</td></tr><tr><td valign="top">irda</td><td valign="top">IrDA提供红外线设备（笔记本，PDA's，手机，计算器等 ）间的通讯支持。关闭</td><td valign="top">关闭</td></tr></tbody></table><div><table border="1" cellpadding="2" cellspacing="0" width="100%"><tbody><tr><td valign="top">irqbalance</td><td valign="top">支持多核处理器，让CPU可以自动分配系统中断（IRQ），提高系统性能。目前服务器多是多核CPU，请开启。</td><td valign="top">开启</td></tr><tr><td valign="top">isdn</td><td valign="top">使用ISDN设备连接网络。目前主流的联网方式是光纤接入和ADSL，ISDN已经非常少见，请关闭</td><td valign="top">关闭</td></tr><tr><td valign="top">kudzu</td><td valign="top">该服务可以在开机时进行硬件检测，并会调用相关的设置软件。建议关闭，仅在需要时开启</td><td valign="top">关闭</td></tr><tr><td valign="top">lvm2-monitor</td><td valign="top">该服务可以让系统支持LVM逻辑卷组，如果分区采用的是LVM方式，那么应该开启，建议开启<br/></td><td valign="top">开启</td></tr><tr><td valign="top">mcstrans</td><td valign="top">SELinux的支持服务。建议启动</td><td valign="top">开启</td></tr><tr><td valign="top">mdmonitor</td><td valign="top">该服务用来监测Software RAID或LVM的信息。不是必须服务，请关闭。</td><td valign="top">关闭</td></tr><tr><td valign="top">mdmpd</td><td valign="top">该服务用来监测Multi-Path设备。不是必须服务。</td><td valign="top">关闭</td></tr><tr><td valign="top">messagebus</td><td valign="top">这是Linux的IPC（Interprocess Communication，进程间通讯）服务，用来在各个软件中交换信息。个人建议关闭。</td><td valign="top">关闭</td></tr><tr><td valign="top">microcode_ctl</td><td valign="top">Intel系统的CPU可以通过这个服务支持额外的微指令集。</td><td valign="top">关闭</td></tr><tr><td valign="top">mysqld</td><td valign="top">mysql数据库服务器。如果需要则开启，否则关闭</td><td valign="top">关闭</td></tr><tr><td valign="top">named</td><td valign="top">DNS服务的守护进程，用来进行域名解析。如果是DNS服务器则开启，否则关闭</td><td valign="top">关闭</td></tr><tr><td valign="top">netfs</td><td valign="top">该服务用于在系统启动时自动挂载网络中的共享文件空间，比如：NFS，Samba等。需要就开启，否则关闭</td><td valign="top">关闭</td></tr><tr><td valign="top">network</td><td valign="top">提供网络设置功能。通过这个服务来管理网络，所以开启</td><td valign="top">开启</td></tr><tr><td valign="top">nfs</td><td valign="top">NFS（Network File System）服务，Linux与Linux之间的文件共享服务。需要就开启，否则关闭。</td><td valign="top">关闭</td></tr><tr><td valign="top">nfslock</td><td valign="top">在Linux中如果使用了NFS服务，为了避免同一个文件被不同的用户同时编辑，所以有这个锁服务。有NFS时开启，否则关闭。</td><td valign="top">关闭</td></tr><tr><td valign="top">ntpd</td><td valign="top">该服务可以通过互联网自动更新时间，使系统时间永远都准确。需要则开启，但不是必须服务</td><td valign="top">关闭</td></tr><tr><td valign="top">pcscd</td><td valign="top">智能检测服务，可以关闭</td><td valign="top">关闭</td></tr><tr><td valign="top">portmap</td><td valign="top">用在远程调用（RPC）的服务，如果没有任何RPC时，可以关闭。主要是NFS和NIS服务需要。</td><td valign="top">关闭</td></tr><tr><td valign="top">psacct</td><td valign="top">该守护进程支持几个监控进程活动的工具</td><td valign="top">关闭</td></tr><tr><td valign="top">rdisc</td><td valign="top">客户端ICMP路由协议</td><td valign="top">关闭</td></tr><tr><td valign="top">readahead_early</td><td valign="top">在系统开机的时候，先将某些进程加载入内存整理，可以加快一点启动速度。</td><td valign="top">关闭</td></tr><tr><td valign="top">readahead_later</td><td valign="top">同上</td><td valign="top">关闭</td></tr><tr><td valign="top">restorecond</td><td valign="top">用于给SELinux监测和重新加载正确的文件。如果开启SELinux则需要开启。</td><td valign="top">关闭</td></tr><tr><td valign="top">rpcgssd</td><td valign="top">与NFS有关的客户端功能。如果没有NFS则关闭</td><td valign="top">关闭</td></tr><tr><td valign="top">rpcidmapd</td><td valign="top">同上</td><td valign="top">关闭</td></tr><tr><td valign="top">rsync</td><td valign="top">远程数据备份守护进程。</td><td valign="top">关闭</td></tr><tr><td valign="top">sendmail</td><td valign="top">sendmail邮件服务的守护进程。如果有邮件服务就开启，否则关闭</td><td valign="top">关闭</td></tr><tr><td valign="top">setroubleshoot</td><td valign="top">该服务用于将SELinux相关信息记录在日志/var/log/message中。建议开启</td><td valign="top">开启</td></tr><tr><td valign="top">smartd</td><td valign="top">该服务用于自动检测硬盘状态。建议开启</td><td valign="top">开启</td></tr><tr><td valign="top">smb</td><td valign="top">网络服务samba的守护进程。可以让Linux和windows之间共享数据。如果需要则开启</td><td valign="top">关闭</td></tr></tbody></table><div><table border="1" cellpadding="2" cellspacing="0" width="100%"><tbody><tr><td valign="top">squid</td><td valign="top">代理服务的守护进程。如果需要则开启，否则关闭</td><td valign="top">关闭</td></tr><tr><td valign="top">sshd</td><td valign="top">ssh加密远程登陆管理的服务。服务器的远程管理必须使用此服务，必须开启</td><td valign="top">开启</td></tr><tr><td valign="top">syslog</td><td valign="top">日志守护进程</td><td valign="top">开启</td></tr><tr><td valign="top">vsftpd</td><td valign="top">vsftp服务的守护进程。如果需要FTP服务开启，否则关闭</td><td valign="top">关闭</td></tr><tr><td valign="top">xfs</td><td valign="top">这个是XWindow的字体守护进程。为图形界面提供字体服务，如果不启动图形界面，就不用开启</td><td valign="top">关闭</td></tr><tr><td valign="top">xinetd</td><td valign="top">超级守护进程。如果有依赖xinetd的服务就必须开启。</td><td valign="top">开启</td></tr><tr><td valign="top">ypbind</td><td valign="top">为NIS（网络信息系统）客户机激活ypbind服务进程</td><td valign="top">关闭</td></tr><tr><td valign="top">yum-updatesd</td><td valign="top">yum的在线升级服务</td><td valign="top">关闭</td></tr></tbody></table><div><br/></div></div></div></div></span>
</div></body></html> 