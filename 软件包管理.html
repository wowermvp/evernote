<html>
<head>
  <title>软件包管理</title>
  <basefont face="宋体" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/600718 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 宋体;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1856"/>
<h1>软件包管理</h1>

<div>
<span style="word-wrap: break-word; -webkit-nbsp-mode: space; -webkit-line-break: after-white-space;">
软件包分类
<div>     源码包（编程言写的未经编译的代码）</div><div>          脚本安装包</div><div>     二进制包（RPM包、系统默认包（经过编译后的））</div><div>     </div><div>     源码包的优点：</div><div>          开源，如果有足够的能力，可以修改源代码</div><div>          可以自由选择所需的功能</div><div>          软件是编译安装，所以更加适合自己的系统，更加稳定效率也更高</div><div>          卸载方便</div><div>     源码包的缺点：</div><div>          安装过程步骤较多，尤其安装较大的软件集合时（如LAMP环境搭建），容易出现拼写错误</div><div>          编译过程时间较长，安装比二进制安装时间长</div><div>          因为是编译安装，安装过程中一旦报错新手很难解决</div><div><br/></div><div>     二进制包</div><div>          分类</div><div>               DPKG包：是由Debian Linux所开发出来的包管理机制，通过DPKG包，Debian Linux就可以进行软件包管理。主要应用在Debian和Ubuntu中。</div><div>               RPM包：是由RedHat公司所开发的包管理系统。功能强大，安装、升级、查询和卸载都非常方便。目前很多Linux都在使用这种包管理方式，包括Fedora、CentOS、SuSe等。</div><div>          特点</div><div>          RPM包的优点：</div><div>               包管理系统简单，只通过几个命令就可以实现包的安装、升级、查询和卸载</div><div>               安装速度比源码包安装快得多</div><div>          RPM包的缺点：</div><div>               经过编译，不再可以看到源代码</div><div>               功能不如源码包灵活</div><div>               依赖性。有时安装软件包a时需要选装b和c，而安装b时需要安装d和e。这时需要先安装d和e，再安装b和c，最后才能安装a包。</div><div>     </div><div>     RPM包依赖性</div><div>     树形依赖：a → b → c</div><div>     环形依赖：a → b → c → a(将软件包a、b、c用一条命令装即可)</div><div>     模块依赖：模块依赖查询网站：www.rpmfind.net</div><div>RPM包管理-rpm包命令管理</div><div>     RPM包安装位置，是安装在默认位置</div><div>     <img src="软件包管理_files/Image.png" type="image/png" data-filename="Image.png" style="cursor: default;cursor: default;cursor: default;cursor: default;"/></div><div>          RPM包安装的服务可以用系统服务管理命令（service）来管理，例如RPM包安装的apache的启动方法是：</div><div>      /etc/rc.d/init.d/httpd start或service httpd start</div><div><br/></div><div>     RPM包命名规则</div><div>     httpd-2.2.15-15.e16.centos.1.i686.rpm</div><div>     httpd               软件包名</div><div>     2.2.15              软件版本</div><div>     15                  软件发布次数</div><div>     e16.centos          适合的Linux平台</div><div>     i686                适合的硬件平台</div><div>     rpm                 rpm包扩展名</div><div>     </div><div>     </div><div>     安装升级与卸载</div><div>          包全名与包名</div><div>          包全名：操作的包是没有安装的软件包时用包全名。而且要注意路径。</div><div>          包名：操作已安装的软件包时，使用包名。是搜索/var/lib/rpm中的数据</div><div>     RPM安装</div><div>          rpm -ivh 包全名</div><div>          选项：</div><div>               -i(install)               安装</div><div>               -v(verbose)          显示详细信息</div><div>               -h(hash)              显示进度</div><div>               --nodeps             不检测依赖性安装。软件安装时会检测依赖性，确定所需底层软件是否安装。如果没有安装则会报错。如果不管依赖性，强行安装，可以使用这个选项。<font color="#FF0000">注意：不检测依赖性安装的软件基本是不能使用的，所以不建议这样做。</font></div><div>               --replacefiles       替换文件安装。如果安装软件包，可是包中部分文件已经存在，那么正常安装时候，会报错“某个文件已经存在”从而导致软件无法安装，使用这个选项可以忽视这个报错，而覆盖安装</div><div>               --replacepkgs     替换软件包安装。如果软件包已经安装，此选项可以把软件包重新安装一遍</div><div>               --force               强制安装。不管是否已经安装，都重新安装。就是--replacefiles和--replacepkgs的综合</div><div>               --test                 测试安装。不会实际安装，只是检测一下依赖性。</div><div>               --prefix               指定安装路径。为安装软件指定安装路径，而不使用默认安装路径。<font color="#FF0000">注意：如果指定了安装路径，软件没有安装到系统默认的路径中的话，系统会找不到这些安装的软件，需要手工进行配置才能被系统识别。所以rpm包我们一般都采用默认路径安装。</font></div><div>     RPM包升级</div><div>          rpm -Uvh 包全名</div><div>          选项：</div><div>               -U（upgrade）     升级安装，如果没有安装过，系统直接安装。如果安装的版本过旧，则升级到新的版本。</div><div>          rpm -Fvh  包全名</div><div>               -F（freshen）      升级安装，如果没有安装过，则不会安装。必须安装有较旧的版本，才能升级。</div><div>     RPM包卸载</div><div>          rpm -e 包名</div><div>          选项：</div><div>               -e(erase)              卸载</div><div>               --nodeps             不检查依赖性</div><div>     </div><div>          [root@localhost～]#rpm -q 包名                              <i>#查询包是否安装</i></div><div><i>          </i>选项：</div><div>               -q     查询（query）</div><div>          [root@localhost～]#rpm -qa                                   <i>#查询所有已安装的RPM包</i></div><div>          选项：</div><div>               -a     所有（all）</div><div>     </div><div>          [root@localhost～]# rpm -qi 包名                           <i>#查询软件包的详细信息</i></div><div>          选项：</div><div>               -i     查询软件信息（information）</div><div>               -p     查询未安装包信息（package）</div><div>           [root@localhost～]# rpm -qip 包全名                    <i>#查询没有安装包的信息</i></div><div>     </div><div>          [root@localhost～]# rpm -ql 包名                         <i>#查询包中文件的安装位置</i></div><div>          选项：</div><div>               -l     列表（list）</div><div>               -p     查询未安装包信息（package）</div><div>          [root@localhost～]# rpm -qlp 包全名                    <i>#查询未安装包中文件的安装位置</i></div><div>     </div><div>          [root@localhost～]# rpm -qf 系统文件名               <i>#查询系统文件属于哪个包</i></div><div>          选项：</div><div>               -f     查询系统文件属于哪个软件包（file）</div><div>     </div><div>          [root@localhost～]#rpm -qR 包名                         <i>#查询软件包的依赖性</i></div><div>          选项：</div><div>               -R     查询软件包的依赖性（requires）</div><div>               -p     查询未安装包的信息（package）</div><div>     rpm包校验</div><div>          [root@localhost～]#rpm -V 已安装的包名</div><div>          选项：</div><div>          -V     校验指定RPM包中的文件（verify）</div><div><br/></div><div>          [root@localhost～]#rpm -Vf 系统文件名</div><div>           选项：</div><div>          -Vf     校验某个系统文件是否被修改</div><div><br/></div><div>          验证内容中的8个信息的具体内容如下：</div><div>               S     文件大小是否改变</div><div>               M     文件类型或文件的权限（rwx）是否改变</div><div>               5     文件MD5校验和是否改变（可以看成文件内容是否改变）</div><div>               D     设备的中，从代码是否改变</div><div>               L     文件路径是否改变</div><div>               U     文件的属主（所有者）是否改变</div><div>               G     文件的属组是否改变</div><div>               T     文件的修改时间是否改变</div><div>          文件类型</div><div>               c     配置文件（config file）</div><div>               d     普通文档（documentation）</div><div>               g     “鬼”文件（ghost file），很少见，就是该文件不应该被这个RPM包包含</div><div>               l     授权文件（license file）</div><div>               r     描述文件（read me）</div><div><br/></div><div>     数字证书</div><div>          上面的校验方法只能对已经安装的RPM包中的文件进行校验，但是如果RPM包本身就被动过手脚，那么校验就不能解决问题了。此时就必须使用数字证书验证了。</div><div>          数字证书有如下特点：</div><div>               首先必须找到原厂的公钥文件，然后进行安装</div><div>               再安装RPM包时，会去提取RPM包中的证书信息，然后和本机安装的原厂证书进验证</div><div>               如果验证通过，则允许安装；如果验证不通过，则不允许安装并警告</div><div>          数字证书位于CentOS6.3的第一张光盘中，当然它默认也会放在系统中。</div><div>               /mnt/cdrom/RPM-GPG-KEY-CentOS-6                <i>#光盘中的数字证书位置</i></div><div>               /etc/pki/rpm-pgp/RPM-GPG-KEY-CentOS-6       <i>#系统中的数字证书保存位置</i></div><div><i>         </i> 数字证书导入</div><div>               rpm --import /etc/pki/rmm-gpg/RPM-GPG-KEY-CentOS-6</div><div>                      --import     导入数字证书</div><div>     RPM包文件提取</div><div>          cpio命令主要有三种基本模式：“-o”模式指的是copy-out模式，就是把数据备份到文件库中；&quot;-i&quot;模式指的是copy-in模式，就是把数据从文件库中恢复；“-p”模式指的是复制模式，就是不把数据备份到cpio库中，而是直接复制为其他文件。命令如下：</div><div>          [root@localhost～]#cpio -o[vcB] &gt; [文件|设备]               <i>#备份</i></div><div>          选项：</div><div>               -o:          copy-out模式，备份</div><div>               -v:          显示备份过程</div><div>               -c:          使用较新的portable format存储方式</div><div>               -B:          设定输入输出块为5120bytes，而不是512bytes</div><div><br/></div><div>           [root@localhost～]#cpio -i[vcdu]  &lt;  [文件|设备]          <i>#还原</i></div><div>           选项：</div><div>               -i:          copy-in模式，还原</div><div>               -v:          显示还原过程</div><div>               -c:          使用较新的portable format存储方式</div><div>               -d:          还原时自动新建目录</div><div>               -u:          自动使用较新的文件覆盖较旧的文件</div><div>          </div><div>          <font color="#FF0000">注意：cpio自己不能指定源文件，只能接收管道符的数据作为源。</font></div><div>          [root@localhost～]#cpio -p 目标目录</div><div>          例：</div><div>          [root@localhost～]#find /boot/ -print | cpio -p /tmp/test          <i>#备份/boot/目录到/tmp/test/目录中</i></div><div>          </div><div>          使用cpio备份数据的方法，命令如下：</div><div>          [root@localhost～]#find /etc/ -print | cpio -ocvB &gt; /root/etc.cpio</div><div>          <i>#利用find指定要备份/etc/目录，使用&gt;导出到etc.cpio文件</i></div><div>          使用cpio恢复cpio的备份数据，命令如下:</div><div>          [root@localhost～]#cpio -idvcu &lt; /root/etc.cpio</div><div>          <i>#还原etc的备份，但是如果大家查看下当前目录/root，会发现没有生成etc目录。这是因为备份/etc/目录使用的是绝对路径，所以恢复的数据直接恢复到了/etc系统目录中，而没有生成在/root/etc中。</i></div><div><i>         </i> 在CentOS5.x的版本中，是可以利用上面的命令备份与恢复指定的文件。但是到CentOS6.x当中，需要更加谨慎。如果备份时使用绝对路径，则恢复的数据会直接到绝对路径指定的路径中，如果需要把数据恢复到当前目录中，则需要使用相对路径，例如：</div><div>          备份：</div><div>          [root@localhost～]#cd /etc     </div><div>          [root@localhost etc]#find . -print | cpio -ocvB &gt; /root/etc.cpio</div><div>          <i>#利用find指定要备份/etc/目录，使用&gt;导出到etc.cpio文件</i></div><div>          恢复：</div><div>          [root@localhost～]#cd /root</div><div>          [root@localhost～]#mkdir etc_test</div><div>          [root@localhost～]#cd etc_test</div><div>          [root@localhost etc_test]#cpio -idvcu &lt; /root/etc.cpio</div><div>          <i>#还原/etc/目录的数据，因为备份时使用的是相对路径，则会还原到/root/etc_test/目录下</i></div><div><i><br/></i></div><div><i>         </i> cpio命令的-p复制模式，命令如下：</div><div>          [root@localhost～]#find /root/ -print | cpio -p /tmp/test/      <i>#备份/boot/目录到/tmp/test/目录中</i></div><div><i><br/></i></div><div><i>         </i> 提取RPM包中文件</div><div>          [root@localhost～]#rpm2cpio 包全名 | cpio -idv .文件绝对路径</div><div>          rpm2cpio     <i>#将rpm包转换成cpio格式命令</i></div><div>          cpio             <i>#是一个标准工具，它用于创建软件档案文件和从档案文件中提取文件</i></div><div><i><br/></i></div><div><i>     </i>范例：以误删/bin/ls为例</div><div><i>          </i>[root@localhost～]# rpm -qf /bin/ls              <i>#查询ls命令属于哪个软件包</i></div><div>          [root@localhost～]# rpm2pico /mnt/cdrom/Packages/coreutils-8.4-19.e16.rpm \</div><div>                              | cpio -idv <font color="#FF0000">.</font>/bin/ls     <i>                #提取RPM包中ls命令到当前目录的/bin/ls下</i></div><div>          [root@localhost～]# cp /root/bin/ls /bin/     <i>#把ls命令复制回/bin/目录，修复文件丢失</i></div><div><br/></div><div>RPM包管理-yum在线管理</div><div>     网络yum源</div><div>          [root@localhost～]# vi /etc/yum.repos.d/CentOS-Base.repo</div><div>               [base]           容器名称，一定要放在[]中</div><div>               name            容器说明，可以自己随便写</div><div>               mirrorlist       镜像站点，这个可以注释掉</div><div>               baseurl         我们的yum源服务器的地址。默认是CenteOS官方的yum源服务器，是可以使用的，</div><div>                                   如果你觉得慢可以改成你喜欢的yum源地址</div><div>               enabled         此容器是否生效，如果不写或写成enable=1都是生效，写成enable=0就是不生效</div><div>               gpgcheck        如果是1是指RPM的数字证书生效，如果是0则不生效</div><div>               gpgkey          数字证书的公钥文件保存位置。不用修改</div><div>     yum命令</div><div>          [root@localhost～]# yum list                      <i>#查询所有可用软件包列表</i></div><div>          [root@localhost～]# yum search 关键字     <i> #搜索服务器上所有和关键字相关的包</i></div><div>     安装</div><div>          [root@localhost～]# yum -y install 包名</div><div>          选项：</div><div>               install     安装</div><div>               -y          自动回答yes</div><div>     升级</div><div>          [root@localhost～]# yum -y update 包名        <i><font color="#FF0000">#慎用</font></i></div><div>          选项：</div><div>               update     升级</div><div>               -y         自动回答yes</div><div>     卸载</div><div>          [root@localhost～]# yum -y remove 包名</div><div>          选项：</div><div>               remove     卸载</div><div>               -y         自动回答yes</div><div><br/></div><div>     yum软件组管理命令</div><div>          [root@localhost～]# yum grouplist                          <i>#列出所有可用的软件组列表</i></div><div><i>          </i>[root@localhost～]#yum groupinfo 软件组名           <i>#列出软件组中包含的软件</i></div><div>          [root@localhost～]# yum groupinstall 软件组名       <i>#安装指定软件组，组名可以由grouplist查询出来</i></div><div>          [root@localhost～]# yum groupremove 软件组名    <i>#卸载指定软件组</i></div><div><i><br/></i></div><div>源码包安装过程</div><div>     源码包安装位置</div><div>          安装在指定位置当中，一般是/usr/local/软件名/</div><div>          源码包安装的服务不能被服务管理命令管理，因为没有安装到默认路径中，所以只能用绝对路径进行服务管理</div><div>      如：/usr/local/apache2/bin/apachectl start</div><div><br/></div><div>     安装注意事项：</div><div>          源代码保存位置：/usr/local/src/</div><div>          软件安装位置：/usr/local/</div><div>          如何确定安装过程报错：</div><div>               安装过程停止</div><div>               并出现error、warning或no的提示</div><div>          安装过程</div><div>               <font color="#FA7A00">下载源码包→解压缩源码包→进入解压缩目录</font></div><div>               ./configure     软件配置与检查</div><div>               定义需要的功能选项</div><div>               检测系统环境是否符合安装要求</div><div>               把定义好的功能选项和检测系统环境的信息都写入Makefile文件，用于后续的编辑</div><div>               </div><div>               [root@localhost～]# ./configure --prefix=/usr/local/apache2  <i>#检查配置，并指定安装目录</i></div><div>               [root@localhost～]# make            <i>#编译</i></div><div>               [root@localhost～]# make install  <i>#编译安装</i></div><div>               [root@localhost～]# /usr/local/apache2/bin/apachectl start</div><div>          源码包卸载</div><div>               不需要卸载命令，直接删除安装目录即可。不会遗留任何垃圾文件。</div><div>     </div><div>     打入补丁</div><div>     1）补丁生成</div><div>     [root@localhost～]#diff 选项 old new          <i>#比较old和new文件的不同</i></div><div>     选项：</div><div>          -a          将任何文档当做文本文档处理</div><div>          -b          忽略空格造成的不同</div><div>          -B          忽略空白行造成的不同</div><div>          -I          忽略大小写造成的不同</div><div>          -N          当比较两个目录时，如果某个文件只在一个目录中，则另一个目录中视作空文件</div><div>          -r          当比较目录时，递归比较子目录</div><div>          -u          使用同一的输出格式</div><div>     举例：</div><div>     [root@localhost～]#mkdir test</div><div>     [root@localhost～]#cd test</div><div>     [root@localhost test]#vi old.txt</div><div>     our</div><div>     school</div><div>     is</div><div>     lampbrother                    <i>#文件old.txt，为了一会输出便于比较，每行分开</i></div><div>     [root@localhost test]#vi new.txt</div><div>     our</div><div>     school</div><div>     is</div><div>     lampbrother</div><div>     in</div><div>     beijing</div><div><br/></div><div>     比较下面一个文件的不同，并生成补丁文件“txt.patch”，命令如下：</div><div>     [root@localhost test]#diff -Naur /root/old.txt /root/test/new.txt &gt; txt.patch</div><div>     <i>#比较两个文件的不同，同时生成txt.patch补丁文件</i></div><div>     [root@localhost test]#more txt.patch                                                       <i>#查看一下这个文件</i></div><div>     --- /root/test/old.txt 2012-11-23 05:51:14. 347954373 +0800              <i>#前一个文件</i></div><div>     +++ /root/test/new.txt 2012-11-23 05:50:05. 772988210 +0800         <i>#后一个文件</i></div><div>     @@ -2,3 +2,5@@</div><div>     school</div><div>     is</div><div>     lampbrother</div><div>     +in</div><div>     +beijing               <i>#后面一个文件比前面一个文件多两行（+表示）</i></div><div><br/></div><div>     2）打入补丁</div><div>     [root@localhost test]#patch -pn &lt; 补丁文件                    <i>#按照补丁文件进行更新</i></div><div>     选项：</div><div>          -pn          n为数字。代表按照补丁文件中的路径，指定更新文件的位置。</div><div>     “-pn”因为补丁文件是要打入旧文件的，但是当前所在的目录和补丁文件中的记录的目录是不一定匹配的，所以就需要“-pn”来同步两个目录。</div><div>     比如当前是在“/root/test/”目录中（我要打补丁的旧文件就在当前目录下），补丁文件中记录的文件目录为“/root/test/old.txt”，这时如果写入“-p1”（在补丁文件目录中取消一级目录）那么补丁文件就会打入“/root/test/root/test/old.txt”文件中，这显然是不对的。那如果写入的是“-p2”（在补丁目录中取消二级目录）那么补丁文件打入的就是“/root/test/test/old.txt”，这显然也不对。如果写入的是“-p3”（在补丁文件目录中取消三级目录）那么补丁文件就是打入的“/root/test/old.txt”,我们的old.txt文件就在这个目录下所以就应该是“-p3”。</div><div>那么更新一下“old.txt”文件，命令如下：</div><div>     [root@localhost test]#patch -p3 &lt; txt.patch                    <i>#给old.txt文件打补丁</i></div><div>     </div><div>脚本安装包</div><div>     脚本安装包不是独立的软件安装类型，常见安装的是源码包。</div><div>     是人为把安装过程写成了自动安装的脚本。只要执行脚本，定义简单的参数，就可以完成安装。</div><div>     非常类似于windows下软件的安装方式。</div><div>     </div><div>     安装 ./setup.sh</div><div>     </div><div>函数库管理</div><div>1、函数库分类</div><div>     静态函数库：函数库文件一般以“*.a”扩展名结尾。这种函数库在被程序调用时会被直接整合到程序当中</div><div>          优点：程序执行时，不需要再调用外部数据，可以直接执行。</div><div>          缺点：因为所有内容都整合到程序中，所以编译生成的文件会比较大，升级比较困难，需要把整个程序都重新编译</div><div>     动态函数库：函数库文件通常以“*.so”扩展名结尾。这种函数库被程序调用时，并没有直接整合到程序当中，当程序需要用函数库的功能时，再去读取函数库。在程序中只保存了函数库的指向。</div><div>                              <img src="软件包管理_files/Image [1].png" type="image/png" data-filename="Image.png" style="cursor: default;cursor: default;"/></div><div>2、<font color="#FF0000">函数库管理</font></div><div>     1）安装函数库</div><div>     [root@localhost test]#ldd -v 可执行文件名（绝对路径）</div><div>     选项：</div><div>          -v          显示详细版本信息</div><div>     例：</div><div>     [root@localhost ～]#ldd /bin/ls                         <i>#查询ls命令调用的函数库</i></div><div>     </div><div>     如果新安装一个函数库，如何让它被系统识别？其实软件如果是正常安装，是不需要手工调整函数库的，它们都会被正常安装。但是万一没有安装正确，需要手工安装，只要把函数库放入指定的位置，一般都放在“/usr/lib”或“/lib”中，然后把函数库所在目录写入“/etc/ld.so.conf”文件。注意是把函数库所在目录名写入，而不是函数库的文件名。比如：</div><div>     [root@localhost ～]# cp *.so /usr/lib/               <i>#把函数库拷贝入/usr/lib目录</i></div><div>     [root@localhost ～]#vi /etc/ld.so.conf              <i>#修改函数库配置文件</i></div><div>     include ld.so.conf.d/*.conf</div><div>     /usr/lib                                                             <i>#写入函数库所在目录（其实/usr/lib目录默认已经被识别）</i></div><div>     </div><div>     然后使用ldconfig命令重新读取/etc/ld.so.conf文件，把新函数库读入缓存即可，命令如下：</div><div>     [root@localhost ～]# ldconfig                           <i>#从/etc/ld.so.conf中把函数库读入缓存</i></div><div>     [root@localhost ～]# ldconfig -p                      <i>#列出系统缓存中所有识别的函数库</i></div><div><br/></div><div><br/></div></span>
</div></body></html> 